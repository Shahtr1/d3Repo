<html>

<body>



<style>

			.subBar { 
			  fill: gray;
			  opacity: 0.5;
			}
			
			.axis path,
			.y-axis line {
			  fill: none;
			  stroke: #000;
			  shape-rendering: crispEdges;
			}
			
			
			
			.brush .extent {
			  stroke: #fff;
			  fill: steelblue;
			  fill-opacity: .25;
			  shape-rendering: crispEdges;
			}
			
			  rect.mover {
			            stroke: red;
			            stroke-opacity: .1;
			            fill: lightSteelBlue ;
			            fill-opacity: .5;
			        }
            .y-axis path{
            	fill: none;
                stroke: black;
                shape-rendering: crispEdges;
                
            }
            
            .y-axis line {
                fill: none;
                stroke: lightgray;
                shape-rendering: crispEdges;
                stroke-opacity: 0.7;
            }

            .x-axis path, .x-axis line{
            	display:none;

            }
            
            .x-axis, .y-axis text {
                font-family: sans-serif;
                font-size: 10px;
            }
            
            h2 {
                font-family: 'Open Sans', sans-serif;
                font-weight: 300;
                font-size: 16px;
                margin-bottom: 5px;
            }
            
           div.tooltip {   
                    position: absolute;
                    max-width: 200px;
                    height: auto;
                    padding: 5px;
                    background-color: white;
                    -webkit-border-radius: 5px;
                    -moz-border-radius: 5px;
                    border-radius: 5px;
                    -webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
                    -moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
                    box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
                    pointer-events: none; /* MUI IMPORTANTE! */
                    font-family: sans-serif;
                    font-size:12px;
            }


            #dashTitle {
            	display: block;
            	margin: auto;
            	font-family: 'Open Sans', sans-serif;
            }

            #barChartLegend {
            	overflow: visible;

            }

            .profitLabel {
            	font-family: 'Open Sans', sans-serif;	
            	font-size: 12px;
            }
			.center {
				display: block;
				margin-left: auto;
				margin-right: auto;
				width: 50%;
			}
			
			
			    .disable{
			        fill: #c0c0c05e !important;
			    }   
</style>
<!-- Second Bar Chart CSS -->
<style>
		.selectOption {
			width:314px !important;
		}
		.selectOption_2 {
			width:314px !important;
		}
		
		.subBar_2 { 
		  fill: gray;
		  opacity: 0.5;
		}
		
		.axis path,
		.y-axis_2 line {
		  fill: none;
		  stroke: #000;
		  shape-rendering: crispEdges;
		}
		
		.selectOption_2{
			margin-left: auto;
		    margin-right: auto;
		}
		
		.brush .extent {
		  stroke: #fff;
		  fill: steelblue;
		  fill-opacity: .25;
		  shape-rendering: crispEdges;
		}
		
		  rect.mover_2 {
		            stroke: red;
		            stroke-opacity: .1;
		            fill: lightSteelBlue ;
		            fill-opacity: .5;
		        }
		
		   
		     

            .y-axis_2 path{
            	fill: none;
                stroke: black;
                shape-rendering: crispEdges;
                
            }
            
            .y-axis_2 line {
                fill: none;
                stroke: lightgray;
                shape-rendering: crispEdges;
                stroke-opacity: 0.7;
            }

            .x-axis_2 path, .x-axis_2 line{
            	display:none;

            }
            
            .x-axis_2, .y-axis_2 text {
                font-family: sans-serif;
                font-size: 10px;
            }
            
            h2 {
                font-family: 'Open Sans', sans-serif;
                font-weight: 300;
                font-size: 16px;
                margin-bottom: 5px;
            }
            
           div.tooltip_2 {   
                    position: absolute;
                    max-width: 200px;
                    height: auto;
                    padding: 5px;
                    background-color: white;
                    -webkit-border-radius: 5px;
                    -moz-border-radius: 5px;
                    border-radius: 5px;
                    -webkit-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
                    -moz-box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
                    box-shadow: 4px 4px 10px rgba(0, 0, 0, 0.4);
                    pointer-events: none; /* MUI IMPORTANTE! */
                    font-family: sans-serif;
                    font-size:12px;
            }


            #dashTitle {
            	display: block;
            	margin: auto;
            	font-family: 'Open Sans', sans-serif;
            }

            #barChartLegend_2 {
            	overflow: visible;

            }

            .profitLabel {
            	font-family: 'Open Sans', sans-serif;	
            	font-size: 12px;
            }
			.center {
				display: block;
				margin-left: auto;
				margin-right: auto;
				width: 50%;
			}
</style>

<script>





function noBack(){window.history.forward();}
noBack();
window.onload=noBack;
window.onpageshow=function(evt){if(evt.persisted)noBack();}
window.onunload=function(){void(0);}
</script>

<style>

.selectOption{
	display:inline-block;
}

@media screen and (min-width: 1140px) {
	.item1 { grid-area: item1; }
	.item2 { grid-area: item2; }
	
	.grid-container {
	  display: grid;
	  grid-template-areas:
	    'item1 item2';
	    justify-items: center;
	  align-items: center;
	  grid-gap: 10px;
	}
	.myCards{
	padding:20px 0;
	margin: 10px 50px;
}

.headingTextShow{
	display:none;
}

.headingTextHide{
	display:block;
}

.forlarge{
	margin-top:0px;	
}

.refresh{
	right:50px !important;
}
	
}	

@media screen and (max-width: 1140px) {
 .item1 { grid-area: item1; }
.item2 { grid-area: item2; }

.grid-container {
  display: grid;
  grid-template-areas:
    'item1'
    'item2';
    justify-items: center;
  align-items: center;
  grid-gap: 10px;
}
.myCard{
	padding:16px 0;
	}
	
	.myCards{
	margin-bottom: 10px;
}

.refresh{
	right:10px !important;
}

.headingTextShow{
	display:block;
}

.headingTextHide{
	display:none;
}

.forlarge{
	margin-top:10px;	
}

}

@media screen and (max-width: 500px) {
	
}


</style>
<style>
 .center {
    display: block;
    margin-left: auto;
    margin-right: auto;
    width: 50%;
}
</style>

<input type="hidden" id="lead_count" value="${lead_count}">
<input type="hidden" id="case_count" value="${case_count}">


<div class="refresh ref"style="position: fixed;z-index: 100; top:9rem;"><button class="btn btn-primary " style="width:42px;height:35px;background-color:#0069aa; "><div class="fa fa-refresh rotate " aria-hidden="true"></div></button> </div>
<div id="fullBarChart" >
	<div align="center">
	<select class="form-control input-sm selectOption select2"  id="userId"  name="user_id"  >
	//NOTE: dont worry about the select dropdowns you can create your own, these are just dynamically loaded by JSP 
	<c:if test="${userList.size()>'1'}">
	<option value="" disabled selected>Select User</option>
	</c:if>
	 <c:forEach var="uid" items="${userList}">
	 <option value="${uid.user_id}">${uid.user_name}- (${uid.user_id})</option>   
		</c:forEach>  
	</select>
	<select class="form-control input-sm selectOption select21"  id="projectId"   name="project_id"  >
	<option value="" disabled selected>Select Project</option>
	 <c:forEach var="pid" items="${projectList}">
	 <option value="${pid.project_id}">${pid.project_name}- (${pid.project_id})</option>   
		</c:forEach>  
	</select> 
	
</div>
		
<div class="headingBars text-center headingTextHide shadow" style="background-color: #f8f9fa;    font-size: 17px; margin-top:10px; margin-left:50px;margin-right:50px; ">Lead Lifecycle</div>
	<div class="grid-container myCards bg-white rounded forlarge"   style="padding:0 !important; min-width:500px;">
	
	<div class="item1 myCard bg-white rounded"   style="display:inline-block !important;">
		<div class="headingBars text-center headingTextShow" style="background-color: #f8f9fa;    font-size: 17px; margin-bottom:10px; ">Lead Lifecycle</div>
		<div id="topChartPie"></div>
	</div>
    <div class="item2 myCard bg-white rounded "   style="display:inline-block;">
    	<div class="headingBars text-center headingTextShow" style="background-color: #f8f9fa;    font-size: 17px;  ">Lead Lifecycle</div>
    	<div id="pie"></div>
    </div>
</div>	
	    
 	    
<div class="grid-container myCards bg-white rounded">
	<div class="item1 myCard bg-white rounded" id="topChart" style="display:inline-block !important; min-width:500px;">
		<div class="headingBars text-center" style="background-color: #f8f9fa;    font-size: 17px;  ">Lead Status</div>
	<!-- 	<div id="barChart"   onclick="buildBar(0,values,0,0)"></div>  -->
		<div id="barChart"  ></div>	
	</div>
    <div class="item2 myCard bg-white rounded" id="topChart_2" style="display:inline-block !important; min-width:500px;">
    <div class="headingBars text-center" style="background-color: #f8f9fa;    font-size: 17px;">Deals Closed & Invoiced</div>
    	   <svg id="barChartLegend_2"></svg>	
    	<!-- <div id="barChart_2"   onclick="buildBar_2(0,values_2,0,0)"></div> -->
    	<div id="barChart_2"   ></div>
    </div>
</div>	    
 	      
</div>

<script>
$(".select2").select2({placeholder:"Select User"});
$(".select21").select2({placeholder:"Select Project"});
</script>
<script>

$('#userId').change(function(){
	buildBar(1,values,0,0);
	buildBar_2(1,values_2,0,0);
});

var timeout = null;

$(document).bind('mousemove keypress keydown keyup', function() {
    if (timeout !== null) {
        clearTimeout(timeout);
    }

    if('${mouse_move}' == true){timeout = setTimeout(refresh,3000 );}
});

/*	First Bar Chart Start	*/

var data = [];
var newArr1 = [];
var isZero = (currentValue) => currentValue == 0;
var l = $.ajax({
		    type: "GET",
		    contentType: "application/json; charset=utf-8",
		    url: "${pageContext.request.contextPath}/getUserLeadData",
		    dataType: 'json',
		    async:false,
		    data : ({
				'1':1
			}), 
		    success: function (data) {
		    	//console.log(data);
		    	var results = JSON.stringify(data);
		        return data;
		    }
		});
		
		
		
	
	console.log(l.responseText);
	
	 //data = JSON.parse(l.responseText);  
	 
	//below line for some static data and for dynamic uncomment above line and comment below line
data = [{"user_id":"AAAA0001","user_name":null,"pending_lead_count":40,"lost_lead_count":20,"created_lead_count":10,"user_count":0},{"user_id":"AAAA0002","user_name":null,"pending_lead_count":45,"lost_lead_count":1,"created_lead_count":4,"user_count":0},{"user_id":"AAAA0003","user_name":null,"pending_lead_count":5,"lost_lead_count":9,"created_lead_count":25,"user_count":0},{"user_id":"AAAA0004","user_name":null,"pending_lead_count":30,"lost_lead_count":5,"created_lead_count":20,"user_count":0},{"user_id":"AAAA0005","user_name":null,"pending_lead_count":20,"lost_lead_count":35,"created_lead_count":7,"user_count":0},{"user_id":"AAAA0006","user_name":null,"pending_lead_count":2,"lost_lead_count":40,"created_lead_count":37,"user_count":0},{"user_id":"AAAA0007","user_name":null,"pending_lead_count":15,"lost_lead_count":0,"created_lead_count":41,"user_count":0},{"user_id":"AAAA0008","user_name":null,"pending_lead_count":12,"lost_lead_count":16,"created_lead_count":1,"user_count":0}]		
	
for(var i = 0;i<data.length;i++){ var valueArr = Object.values( data[i]);for(var val in valueArr){ if(val>1 && val <5){console.log(val);newArr1.push(valueArr[val]);} } }	
	//dashboard///////////////////////////////////////
if(newArr1.every(isZero)) data=[];
	
	var flag = 0;
	var interval = function(){d3.timer(x => d3.json("${pageContext.request.contextPath}/getUserLeadData", function(error, x){console.log("ajax working");flag = 1;values = x; buildBar(0,values,flag,0);}), 1000)};
	//setInterval(d3.timer(x => d3.json("${pageContext.request.contextPath}/getUserLeadData", function(error, x){console.log("ajax working");flag = 1;values = x; buildBar(0,values,flag);})),1000);
	
var counter = 0;

var myInterval;

var found = 0;

var moverToLast = 0;

var moverToFirst = 0;

var of;

var displayFlag=0;

var selectBar;

var firstSubBarLength;

var checkInterval = 0;

var isRefreshing = false;
var values = data;

var firstTime;

var compareData;

var maxValueYAxis;



 buildBar(0,data,0,1);
 
 console.log("isRefreshing"+isRefreshing);
 
 

function buildBar(selectBar,values,flag,firstTime){
	//values
	
	if(values.length == 0){
		$('#barChart').text('');
		var margin =  {top: 20, right: 20, bottom: 20, left: 40};
		var width = 500 - margin.left - margin.right;
		var height = 350 - margin.top - margin.bottom;
		
		var svg = d3.select("#barChart").append("svg")
		.attr("width", width + margin.left + margin.right)
		.attr("height", height + 35 + margin.top + margin.bottom )
		;
		
		var borderPath = svg.append("rect")
			.attr("x", 0)
			.attr("y", 0)
			.attr("height", height + 25 + margin.top + margin.bottom)
			.attr("width", width + margin.left + margin.right)
			.style("stroke", "#908d8d")
			.style("fill", "none")
			.style("stroke-width", 1);
		
		svg.append("rect")
			.attr("x", ((width + margin.left + margin.right)/2)-85)
			.attr("y",((height + 25 + margin.top + margin.bottom)/2)-25)
			.attr("width", 170)
			.attr("height", 50)
			.style("fill", "#908d8d")
			;
		
		svg.append("text")
			.attr("x", ((width + margin.left + margin.right)/2))
			.attr("y",((height + 25 + margin.top + margin.bottom)/2)+10)
			.text("No Data")
			.attr("width", 170)
			.attr("height", 50)
			.style("fill", "#ffffff")
			.attr("font-family","sans-serif")
			.attr("font-size",30)
			.attr("text-anchor","middle")
			;
		
		
		
		
	}else{
			if(selectBar == 1){
				clearInterval(myInterval);
		        isRefreshing = false;
			}
			
			data = values;
			
			checkInterval=0;
			checkInterval++;
			console.log("checkInterval "+checkInterval);
			
		    displayFlag = 1;
		    $('#barChart').text('');
		    
		    var barTooltip = d3.select("#barChart").append("div")   
				    .attr("class", "tooltip")               
				    .style("opacity", 0);
	
		var formatRatio = d3.format("%");            
	
		    
		 
		                    
		var margin =  {top: 20, right: 20, bottom: 20, left: 40};
		var marginOverview = {top: 30, right: 20, bottom: 20, left: 40};
		var selectorHeight = 40;
		var width = 500 - margin.left - margin.right;
		var height = 350 - margin.top - margin.bottom - selectorHeight ;
		var heightOverview = 80 - marginOverview.top - marginOverview.bottom;
		       
		var maxLength = d3.max(data.map(function(d){ return d.user_id.length}));
		var barWidth = (maxLength * 7);
		console.log("barWidth "+barWidth);
		var numBars = Math.round(width/barWidth)-1;
		console.log("numBars "+numBars);
		console.log("width"+width);
		var isScrollDisplayed = barWidth * (data.length+2) > width;
		console.log("isScrollDisplayed::::::::::))))))))))))) "+isScrollDisplayed);
	
	
		var user_id = function(d) { return d.user_id; };
		var pending_lead_count = function(d) { return d.pending_lead_count; };
		var created_lead_count = function(d) { return d.created_lead_count; };
		var lost_lead_count = function(d) { return d.lost_lead_count; };
		var valueObject = function(d) { return [{name:"pending_lead_count", value:pending_lead_count(d)},{name:"created_lead_count", value: created_lead_count(d)}, {name: "lost_lead_count", value: lost_lead_count(d)}]; };
	
		var val = $('#userId').val();
		var colorIndex = 0;
		       
		 for(var i = 0;i<data.length;i++){
		        console.log(data[i].user_id);
		        if(data[i].user_id==val){
		            found = i-(numBars-5);
		            break;
		        }
		    }
	
		    colorIndex = found;
	
		    var dint = data.length - (numBars/2) + 0.5;
		    console.log(dint + 0.5 + " dataaa" );
	
		    if(found<0){
		        found=0;
		    }else if(found>(dint-numBars)){
		        found = data.length-7;
		        console.log("in found")
		    }
		    
		    if(selectBar==0){
		        found=0;
		    }
	
		    console.log("found"+found);
	
		console.log(isScrollDisplayed)
	
		 newData = data.slice(found);
		 console.log(newData);
		 
		 
		  
		var xscale = d3.scale.ordinal()
		                .domain(newData.slice(0,numBars).map(function (d) { return d.user_id; }))
		                .rangeRoundBands([0, width], .1);
		                
		var x1 = d3.scale.ordinal()
					.domain(["pending_lead_count","created_lead_count","lost_lead_count"])
					.rangeRoundBands([0, xscale.rangeBand()]);                 
	
	
	
		var a = [];
	
		for(var i=0 ;i<data.length;i++){a.push((oValues = Object.values(data[i]).filter(e => typeof(e) !== 'string')).reduce(function(a, b) {
		    return Math.max(a, b);
		}))}
	
		console.log("This is a ==========================="+a);
	
		maxValueYAxis = a.reduce(function(a, b) {
					    return Math.max(a, b);
					});
					
		console.log("maxValueYAxis ==============  " + maxValueYAxis);			
					
					
	
	
	
		var yscale = d3.scale.linear()
		              .domain([0, maxValueYAxis])
		              .range([height, 0]);
		  
		var xAxis  = d3.svg.axis().scale(xscale).orient("bottom");
		var yAxis  = d3.svg.axis().scale(yscale).orient("left").tickSize(-width, 0, 0).tickFormat(d3.format("s"))
		.ticks(10);
	
		var color = d3.scale.ordinal()
						.domain(["created_lead_count","pending_lead_count","lost_lead_count"])
						.range(["#31a354","#3182bd","#e6550d"]);
	
			  
			
		var svg = d3.select("#barChart").append("svg")
								.attr("width", width + margin.left + margin.right)
		            .attr("height", height + 40 + margin.top + margin.bottom + selectorHeight);
		 
		var marginTop = margin.top+30;
	
		var diagram = svg.append("g")
			.attr("transform", "translate(" + margin.left + "," + marginTop + ")");
	
	
	
		diagram.append("g")
		  		 .attr("class", "x axis x-axis")
		       .attr("transform", "translate(0, " + height + ")")
		       .call(xAxis);
		  
		diagram.append("g")
		       .attr("class", "y axis y-axis")
		       .call(yAxis);
		  
		var bars = diagram.selectAll(".bar")
					.data(newData.slice(0,numBars))    
					.enter()
					.append("g")
					.attr("class", "bar")
					.attr("transform", function(d,i) { return "translate(" + xscale(user_id(d)) + ",0)"; })
					;
					
					
	
		var inBars = bars.selectAll("rect")
					    .data(valueObject)  
					    .enter().append("rect");
	
		var userlegendArray=[];
		  
		inBars    
			.attr("x", function(d) { return x1(d.name); })
			.attr("width", x1.rangeBand())
			.attr("y", function (d) { return yscale(0); })
			.attr("height", 0)
			;
		            
		if(flag==1){
			inBars            
		    .transition().duration(0)
		    .ease("cubic")
		    .attr("y", function (d) { return yscale(d.value); })
		    .attr("height", function (d) { return height - yscale(d.value); })
		    .attr("fill", function(d) { return color(d.name); })
		    ;
		}else if(firstTime==1){
			inBars            
		    .transition().duration(2000)
		    .ease("cubic")
		    .attr("y", function (d) { return yscale(d.value); })
		    .attr("height", function (d) { return height - yscale(d.value); })
		    .attr("fill", function(d) { return color(d.name); })
		    ;
		}else{
			inBars
		    .attr("y", function (d) { return yscale(d.value); })
		    .attr("height", function (d) { return height - yscale(d.value); })
		    .attr("fill", function(d) { return color(d.name); })
		    ;
		}
	
	
	
			
			
	
		var dataNumber = bars.selectAll("text")
			.data(valueObject).enter()
			.append("text");
		dataNumber	
			.text(function(d){if(selectBar!=1)return d.value;})
			.attr("text-anchor","middle")
			.attr("x", function(d) { return x1(d.name) + (x1.rangeBand()/3); })
			.attr("y",height)
			.transition().duration(function(){if(flag != 1 && firstTime == 1) return 2000;else return 0;})
			.ease("cubic")
			.attr("y",function(d){console.log("d.value ========== " + d.value);if(d.value!=0) return (yscale(d.value)-2); else return height;})
			.attr("font-family","sans-serif")
			.attr("font-size",10)
			.attr("fill",function(d){return "#000000";});
	
	
		if(selectBar==1){
			
			
			for(i=0;i<newData.length;i++){if(newData[i]['user_id']==val){userlegendArray=(Object.values(newData[i]).filter(e => typeof(e) !== 'string').filter(e => e !== null))}}
			var temp;
			temp = userlegendArray[1];
			userlegendArray[1] = userlegendArray[2];
			userlegendArray[2] = temp;
			console.log("userlegendArray -------------------------  " + userlegendArray);
			
		var userLegend = svg.selectAll(".userLegend")
			.data(["pending_lead_count","created_lead_count","lost_lead_count"])
			.enter().append("g")
			.attr("class", "userLegend")
			.attr("transform", function(d, i) { if(i==0)return "translate(-300,20)";else if(i==1)return "translate(-170,20)";else return "translate(-50,20)"; });
	
		userLegend
			.data(userlegendArray)
			.append("text")
			.attr("x", width+17)
			.attr("y", 9)
			.attr("dy", ".25em")
			.style("fill", "#000000")
			.text(function(d,i) { return userlegendArray[i]; })
		}
	
	
	
		function name(d){
			if(d=='pending_lead_count')
				return 'WIP';
			else if(d=='created_lead_count')
				return 'Qualified';
			else
				return 'Rejected';
		}
	
		var legend = svg.selectAll(".legend")
						.data(["pending_lead_count","created_lead_count","lost_lead_count"])
						.enter().append("g")
						.attr("class", "legend")
						.attr("transform", function(d, i) { if(i==0)return "translate(-300,20)";else if(i==1)return "translate(-170,20)";else return "translate(-50,20)"; });
	
		legend.append("rect")
				.attr("x", width)
				.attr("width", 15)
				.attr("height", 15)
				.style("fill", color);
	
		legend.append("text")
				.attr("x", width - 6)
				.attr("y", 9)
				.attr("dy", ".35em")
				.style("text-anchor", "end")
				.text(function(d) { return name(d); })
	
	
		/////////////////////////////////////////////////
	
	
	
	
	
				
	
	
		//d3.selectAll("rect").style("fill", function(d) { return color(d.lead_count); }).on("mouseover", function(d) {      
		 d3.selectAll(".bar rect").on("mouseover", function(d) {      
		    
			 d3.select(this).style("fill", d3.rgb(color(d.name)).darker(2));	 
	
		barTooltip.transition()        
		    .duration(500)      
		    .style("opacity", .9);      
	
	
		var n = name(d.name);
	
		var tip = "<strong>"+n+":</strong> " + d.value+ "<br/>";
	
	
		barTooltip.html(tip)  
		    .style("left", (d3.event.pageX) + "px")     
		    .style("top", (d3.event.pageY - 28) + "px");    
		})                  
		.on("mouseout", function(d) {       
	
			d3.select(this).style("fill", color(d.name));
		barTooltip.transition()        
		    .duration(500)      
		    .style("opacity", 0);   
		}); 
	
	
	
	
		if(selectBar==1){
			d3.selectAll("g[class='bar'] ").classed("disableg",false);
			console.log("In select bar function===================");
		    d3.selectAll("g[class='bar'] ").classed("disableg",function(d,i){console.log("val " + val);console.log("user_id " + d.user_id);if(d.user_id!=val){return true}else{return false}});
		    $('.disableg rect').addClass('disable');
		    
		}
	
	
		  
		if (isScrollDisplayed)
		{
			var xOverview = d3.scale.ordinal()
							    .domain(data.map(user_id))
							    .rangeBands([0, width], .2);
			
			var xOverview1 = d3.scale.ordinal()
							    .domain(["pending_lead_count","created_lead_count","lost_lead_count"])
							    .rangeRoundBands([0, xOverview.rangeBand()]);
			
		  yOverview = d3.scale.linear().range([heightOverview, 0]);
		  yOverview.domain(yscale.domain());
	
		  var subBars = diagram.selectAll('.subBar')
		      .data(data)
		      
	
		  var subBars = diagram.selectAll('.sub')
		        .data(data)
		        .enter()
		        .append("g")
		        .attr("class","sub")
		        .attr("transform", function(d) { return "translate(" + xOverview(user_id(d)) + ",0)"; })
		        .classed("selectedSubBar",function(d,i){if(d.user_id==val && i>6 && i<data.length-7){return true}else{return false;}})
		        .classed("lastSubBar",function(d,i){if(i==data.length-1){return true}else{return false;}})
		        .classed("firstSubBar",function(d,i){if(i==0){return true}else{return false;}}) 
		        ;
		    
		    
		    subBars.selectAll("rect")
		        .data(valueObject)
		        .enter().append("rect")
		        .classed('subBar', true)                   
		        .attr("x", function(d) {return xOverview1(d.name);})
		        .attr("width", function(d) {return xOverview1.rangeBand()})
		        .attr("y", function (d) { return height + heightOverview + yOverview(0); })
		        .attr("height", 0)
		        .transition().duration(function(d){if(flag!=1)return 1500;else return 0;})
		        .attr("y", function(d) {
		        return height + heightOverview + yOverview(d.value)
		    })
		        .attr("height", function(d) {
		        return heightOverview - yOverview(d.value);
		    });
	
		  var displayed = d3.scale.quantize()
		              .domain([0, width])
		              .range(d3.range(data.length+2));
	
		  diagram.append("rect")
		              .attr("transform", "translate(0, " + (height + margin.bottom) + ")")
		              .attr("class", "mover")
		              .attr("x", 0)
		              .attr("y", 0)
		              .attr("height", selectorHeight)
		              .attr("width", Math.round(parseFloat(numBars * width)/data.length))
		              .attr("pointer-events", "all")
		              .attr("cursor", "ew-resize")
		              .call(d3.behavior.drag().on("drag", display));
	
		              console.log("float  " + Math.round(parseFloat(numBars * width)/data.length)/2);
	
		        var rectWidth = $('.subBar').width();
				console.log("Yeh hai data " + data);
		        for(var checker = 0; checker < data.length; checker++){
		            if(data[checker].user_id==val){
		                if(checker>data.length-8){
		                    moverToLast = 1;
		                    moverToFirst = 0;
		                }else if(checker<7){
		                    moverToLast = 0;
		                    moverToFirst = 1;
		                }else{
		                    moverToFirst = 0;
		                    moverToLast = 0;
		                }
		            }
		            moverToFirst = 1;
		            
		        }
	
		        console.log("moverToLast",moverToLast);
	
		        firstSubBarLength = $('.firstSubBar').offset().left - 8;
	
		        console.log("moverToFirst "+moverToFirst);
	
		        if(moverToLast == 1){
		        	console.log("--------------------------------- IN 1");
		            console.log(rectWidth + " rectWidth");
		            console.log($('.lastSubBar').offset().left + " $('.lastSubBar').offset().left");
		            of = Math.round($('.lastSubBar').offset().left + rectWidth - (parseFloat(numBars * width)/data.length)) - firstSubBarLength;
		        }else if(moverToFirst == 1){
		        	console.log("--------------------------------- IN 2");
		            of = 0;
		        }else if((flag == 1 || flag == 0)&& moverToLast==1 && moverToFirst==1){
		        	console.log("--------------------------------- IN 3");
		        	of = 0;
		        }else if(moverToLast==0 && moverToFirst==0 && selectBar!=1){
		        	console.log("--------------------------------- IN 4");
		        	of = 0;
		        }else{
		        	console.log("--------------------------------- IN 5");
		        	of = Math.round($('.selectedSubBar').offset().left - firstSubBarLength - (parseFloat(numBars * width)/data.length/2)) + (rectWidth*3);
		        }      
	
		    console.log("of ",of) ;        
	
		    if(selectBar==1){
		        d3.selectAll('.mover').attr("x",of);
		    }else{
		        d3.selectAll(".subBar").classed("selectedSubBar",false);
		    }
		    
		    compareData = data;
	
		}
		function display () {
	
			$('.userLegend').text('');
			
			
			
			$('.disableg rect').removeClass('disable');
			d3.selectAll("g[class='bar'] ").classed("disableg",false);
			
		    d3.selectAll(".subBar").classed("selectedSubBar",false);
	
		    selectBar=0;
		    if(counter==0){
		        //buildBar(0,values,0,0);
		        counter = 1;
		    }
	
		    //$("#userId").val($("#userId option:first").val());
		    console.log("this is lead count "+lead_count);
		    d3.selectAll(".bar").classed("disable",false);
		    var x = parseInt(d3.select(this).attr("x")),
		        nx = x + d3.event.dx,
		        w = parseInt(d3.select(this).attr("width")),
		        f, nf, new_data, rects;
	
		        console.log("display x :" + x);
		        console.log("this is nx "+nx);
		        console.log("this is w: "+w);
		        
		        console.log("this is width: "+width);
	
		        console.log("nxwwidth " + (nx + w) > width);
		        console.log(" nx0 " +  nx < 0);
		    
		        
		    if ( nx < 0 || nx + w > width ) return;
		   
		    d3.select(this).attr("x", nx);
	
		    f = displayed(x);
		    nf = displayed(nx+1);
		    console.log(f === nf);
	
		    if ( f === nf ) return;
	
	
		    new_data = data.slice(nf, nf + numBars);
		    for(i=0;i<new_data.length;i++){
		        console.log("new data " + new_data[i].user_id);
		    }
		    
	
		    xscale.domain(new_data.map(user_id));
		    diagram.select(".x.axis").call(xAxis);
		 
		    
		    
		    
		bars
			.data(new_data);
		     
		inBars.data(valueObject);
	
		inBars
		    .attr("x", function(d) { return x1(d.name); })
		    .attr("width", x1.rangeBand())
		    .attr("y", function (d) { return yscale(0); })
		    .attr("height", 0)
		    .attr("y", function (d) { return yscale(d.value) })
		    .attr("height", function (d) { return height - yscale(d.value); })
		    .attr("fill", function(d) { return color(d.name); })
		    ;
	
		dataNumber	
			.data(valueObject)
			.text(function(d){if(selectBar!=1)return d.value;})
			.attr("x", function(d) { return x1(d.name) + (x1.rangeBand()/3); })
			.attr("y",function(d){console.log("d.value ========== " + d.value);if(d.value!=0) return (yscale(d.value)-2); else return height;})
			.attr("font-family","sans-serif")
			.attr("font-size",10)
			.attr("fill",function(d){return "#000000";}); 
			
			
	
		     // d3.selectAll("rect[class='bar']").style("fill", function(d) { return color(d.lead_count); });
		      
		      
	
		};
	}
	



}


/*	First Bar Chart End	*/


/*	Second Bar Chart Start	*/

var data_2 = [];
var newArr1 = [];
var isZero = (currentValue) => currentValue == 0;
var l_2 = $.ajax({
    type: "GET",
    contentType: "application/json; charset=utf-8",
    url: "${pageContext.request.contextPath}/getDealsClosedInvoicedData",
    dataType: 'json',
    async:false,
    data : ({
		'1':1
	}), 
    success: function (data) {
    	//console.log(data);
    	var results = JSON.stringify(data);
        return data;
    }
});

console.log(l_2.responseText);

//data_2 = JSON.parse(l_2.responseText);
//below line for some static data and for dynamic uncomment above line and comment below line
data_2 = [{"user_id":"AAAA0001","user_name":null,"pending_lead_count":0,"lost_lead_count":0,"created_lead_count":0,"user_count":2},
		{"user_id":"AAAA0002","user_name":null,"pending_lead_count":0,"lost_lead_count":0,"created_lead_count":1,"user_count":1},
		{"user_id":"AAAA0003","user_name":null,"pending_lead_count":0,"lost_lead_count":0,"created_lead_count":0,"user_count":7},
		{"user_id":"AAAA0009","user_name":null,"pending_lead_count":0,"lost_lead_count":0,"created_lead_count":0,"user_count":3},
		{"user_id":"AAAA0010","user_name":null,"pending_lead_count":0,"lost_lead_count":0,"created_lead_count":0,"user_count":19},
		{"user_id":"AAAA0011","user_name":null,"pending_lead_count":0,"lost_lead_count":0,"created_lead_count":0,"user_count":30},
		{"user_id":"AAAA0013","user_name":null,"pending_lead_count":0,"lost_lead_count":0,"created_lead_count":0,"user_count":24},
		{"user_id":"AAAA0017","user_name":null,"pending_lead_count":0,"lost_lead_count":0,"created_lead_count":0,"user_count":45},
		{"user_id":"ROHI1234","user_name":null,"pending_lead_count":0,"lost_lead_count":0,"created_lead_count":0,"user_count":0}]


for(var i = 0;i<data_2.length;i++){ var valueArr = Object.values( data_2[i]);for(var val in valueArr){ if(val == 5){console.log(val);newArr1.push(valueArr[val]);} } }	
if(newArr1.every(isZero)) data_2=[];

var flag_2 = 0;
var interval_2 = function(){d3.timer(x => d3.json("${pageContext.request.contextPath}/getDealsClosedInvoicedData", function(error, x){console.log("ajax2 working");values_2 = x; buildBar_2(0,values_2,1,0);}), 1000)};
	
var counter_2 = 0;

var myInterval_2;

var found_2 = 0;

var moverToLast_2 = 0;

var moverToFirst_2 = 0;

var of_2;

var displayFlag_2=0;

var selectBar_2;

var firstSubBarLength_2;

var checkInterval_2 = 0;

var isRefreshing_2 = false;
var values_2 = data_2;

var firstTime_2;

var compareData_2;

buildBar_2(0,data_2,0,1);


console.log("isRefreshing"+isRefreshing_2);

function buildBar_2(selectBar_2,values_2,flag_2,firstTime_2){
	//values_2=[];
	if(values_2.length == 0){
		$('#barChartLegend_2').hide();
		$('#barChart_2').text('');
		var margin_2 =  {top: 20, right: 20, bottom: 20, left: 40};
		var width_2 = 500 - margin_2.left - margin_2.right;
		var height_2 = 350 - margin_2.top - margin_2.bottom;
		
		var svg_2 = d3.select("#barChart_2").append("svg")
			.attr("width", width_2 + margin_2.left + margin_2.right)
			.attr("height", height_2 + 35 + margin_2.top + margin_2.bottom );
		
		var borderPath = svg_2.append("rect")
			.attr("x", 0)
			.attr("y", 0)
			.attr("height", height_2 + 25 + margin_2.top + margin_2.bottom)
			.attr("width", width_2 + margin_2.left + margin_2.right)
			.style("stroke", "#908d8d")
			.style("fill", "none")
			.style("stroke-width", 1);
		
		svg_2.append("rect")
			.attr("x", ((width_2 + margin_2.left + margin_2.right)/2)-85)
			.attr("y",((height_2 + 25 + margin_2.top + margin_2.bottom)/2)-25)
			.attr("width", 170)
			.attr("height", 50)
			.style("fill", "#908d8d")
			;
		
		svg_2.append("text")
			.attr("x", ((width_2 + margin_2.left + margin_2.right)/2))
			.attr("y",((height_2 + 25 + margin_2.top + margin_2.bottom)/2)+10)
			.text("No Data")
			.attr("width", 170)
			.attr("height", 50)
			.style("fill", "#ffffff")
			.attr("font-family","sans-serif")
			.attr("font-size",30)
			.attr("text-anchor","middle")
			;
	}else{
		$('#barChartLegend_2').show();
		if(selectBar_2 == 1){
			clearInterval(myInterval_2);
	        isRefreshing_2 = false;
		}
		
		data_2 = values_2;
		
		checkInterval_2=0;
		checkInterval_2++;
		console.log("checkInterval "+checkInterval_2);
		
		displayFlag_2 = 1;
	    $('#barChart_2').text('');
	    
	    var barTooltip_2 = d3.select("#barChart_2").append("div")   
			    .attr("class", "tooltip_2")               
			    .style("opacity", 0);

		var formatRatio_2 = d3.format("%");
		
		var margin_2 =  {top: 20, right: 20, bottom: 20, left: 40};
		var marginOverview_2 = {top: 30, right: 20, bottom: 20, left: 40};
		var selectorHeight_2 = 40;
		var width_2 = 500 - margin_2.left - margin_2.right;
		var height_2 = 350 - margin_2.top - margin_2.bottom - selectorHeight_2 ;
		var heightOverview_2 = 80 - marginOverview_2.top - marginOverview_2.bottom;
		       
		var maxLength_2 = d3.max(data_2.map(function(d){ return d.user_id.length}));
		var barWidth_2 = (maxLength_2 * 7);
		console.log("barWidth_2 "+barWidth_2);
		var numBars_2 = Math.round(width_2/barWidth_2)-1;
		console.log("numBars_2 "+numBars_2);
		console.log("width_2 "+width_2);
		var isScrollDisplayed_2 = barWidth_2 * (data_2.length+2) > width_2;

		var val_2 = $('#userId').val();
		var colorIndex_2 = 0;
		
		for(var i = 0;i<data_2.length;i++){
	        console.log(data_2[i].user_id);
	        if(data_2[i].user_id==val_2){
	            found_2 = i-(numBars_2 - 5);
	            break;
	        }
	    }

	    colorIndex_2 = found_2;

	    var dint_2 = data_2.length - (numBars_2/2) + 0.5;
	    console.log(dint_2 + " dataaa_2");

	    if(found_2<0){
	        found_2=0;
	    }else if(found_2>(dint_2-numBars_2)){
	        found_2 = data_2.length-7;
	        console.log("in found_2")
	    }
	    
	    if(selectBar_2==0){
	        found_2=0;
	    }

	    console.log("found_2 "+found_2);
	    
	    console.log(isScrollDisplayed_2)

	    newData_2 = data_2.slice(found_2);
	    console.log(newData_2);
	     
	   var xscale_2 = d3.scale.ordinal()
	                   .domain(newData_2.slice(0,numBars_2).map(function (d) { return d.user_id; }))
	                   .rangeRoundBands([0, width_2], .1);

	   var yscale_2 = d3.scale.linear()
	                 .domain([0, d3.max(data_2, function (d) { return d.user_count; })])
	                 .range([height_2, 0]); 
	   
	   var xAxis_2  = d3.svg.axis().scale(xscale_2).orient("bottom");
	   var yAxis_2  = d3.svg.axis().scale(yscale_2).orient("left").tickSize(-width_2, 0, 0).tickFormat(d3.format("s"))
	   .ticks(10);

	       var minProfit_2 = d3.min(data_2, function(d){ return d.user_count; });
	   	var maxProfit_2 = d3.max(data_2, function(d){ return d.user_count; });
	   	
	   	var color_2 = d3.scale.quantize()
	   		.domain([minProfit_2, maxProfit_2])							
	   		.range(['rgb(165,15,21)','rgb(222,45,38)','rgb(251,106,74)','rgb(252,146,114)','rgb(252,187,161)','rgb(254,229,217)','rgb(227, 243, 240)','rgb(204,236,230)','rgb(153,216,201)','rgb(102,194,164)','rgb(44,162,95)','rgb(0,109,44)']);
	   	                
	   var svg_2 = d3.select("#barChart_2").append("svg")
	   						.attr("width", width_2 + margin_2.left + margin_2.right)
	               .attr("height", height_2 + 20 + margin_2.top + margin_2.bottom + selectorHeight_2);
	   
	   var marginTop = margin_2.top+13;
	   
	   var diagram_2 = svg_2.append("g")
	   	.attr("transform", "translate(" + margin_2.left + "," + marginTop + ")");
	     
	   diagram_2.append("g")
	     		 .attr("class", "x_2 axis_2 x-axis_2")
	          .attr("transform", "translate(0, " + height_2 + ")")
	          .call(xAxis_2);
	     
	   diagram_2.append("g")
	          .attr("class", "y_2 axis_2 y-axis_2")
	          .call(yAxis_2);
	   
	   var bars_2 = diagram_2.append("g");
	   
	   bars_2.selectAll("rect")
	               .data(newData_2.slice(0, numBars_2), function (d) {return d.user_id; })
	               .enter().append("rect")
	               .attr("class", "bar_2")
	               .attr("x", function (d) { return xscale_2(d.user_id); })
	               .attr("width", xscale_2.rangeBand())
	               .attr("y", function (d) { return yscale_2(0); })
	               .attr("height", 0);
	               
	   if(flag_2==1){
	   	bars_2.selectAll("rect")            
	       .transition().duration(0)
	       .ease("cubic")
	       .attr("y", function (d) { return yscale_2(d.user_count); })
	       .attr("height", function (d) { return height_2 - yscale_2(d.user_count); })
	       ;
	   }else if(firstTime_2==1){
	   	bars_2.selectAll("rect")            
	       .transition().duration(2000)
	       .ease("cubic")
	       .attr("y", function (d) { return yscale_2(d.user_count); })
	       .attr("height", function (d) { return height_2 - yscale_2(d.user_count); })
	       ;
	   }else{
	   	bars_2.selectAll("rect")
	       .attr("y", function (d) { return yscale_2(d.user_count); })
	       .attr("height", function (d) { return height_2 - yscale_2(d.user_count); })
	       ;
	   }
	   
	   
	   //////////////////////////////////
	   
	   var dataNumber_2 = bars_2.selectAll("text")
		.data(newData_2.slice(0, numBars_2)).enter()
		.append("text");
	   dataNumber_2	
		.text(function(d){if(selectBar_2!=1){return d.user_count;}else if(d.user_id==val_2){return d.user_count;}})
		.attr("text-anchor","middle")
		.classed('text',true)
		.attr("x", function(d) { return xscale_2(d.user_id) + (xscale_2.rangeBand()/2); })
		.attr("y",height_2)
		.transition().duration(function(){if(flag_2 != 1 && firstTime_2 == 1) return 2000;else return 0;})
		.ease("cubic")
		.attr("y",function(d){if(d.user_count!=0) return (yscale_2(d.user_count)-2); else return height_2;})
		.attr("font-family","sans-serif")
		.attr("font-size",10)
		.attr("fill",function(d){return "#000000";});
		
		
		///////////////////////////////////////
	   
	   d3.selectAll("rect[class='bar_2']").on("mouseover", function(d) {      
		     console.log('mouseOver');
		   d3.select(this).style("fill", function(){if(typeof color_2(d.user_count)!=='undefined'){console.log('undefined');return d3.rgb(color_2(d.user_count)).darker(2);}else{return '#003616';}});

		   barTooltip_2.transition()        
		       .duration(500)      
		       .style("opacity", .9);      

		   var tip_2 = "<strong>User ID:</strong> " + d.user_id + "<br/>";
		   var tip_2 = tip_2+"<strong>Deals:</strong> " + d.user_count+ "<br/>";

		   user_count = d.user_count;

		   barTooltip_2.html(tip_2)  
		       .style("left", (d3.event.pageX) + "px")     
		       .style("top", (d3.event.pageY - 28) + "px");    
		   })                  
		   .on("mouseout", function(d) {       
			
			   d3.select(this).style("fill", function(){if(typeof color_2(d.user_count)!=='undefined'){console.log('undefined');return d3.rgb(color_2(d.user_count));}else{return '#006d2c';}});	   
			   
		   barTooltip_2.transition()        
		       .duration(500)      
		       .style("opacity", 0);   
		   });
	   
	   d3.selectAll("rect[class='bar_2']").style("fill", function(d) { console.log("In Color Function::::::::::::::::::::--- "+color_2(d.user_count));if(typeof color_2(d.user_count)!=='undefined') {console.log("not undefined");return color_2(d.user_count);}else {console.log("undefined");return "rgb(0,109,44)";} })
	   
	   if(selectBar_2==1){
		   console.log("In SelectBar Check-------------??????????????"); 
		   d3.selectAll("rect[class='bar_2']").classed("disable",function(d){if(d.user_id!=val_2){return true}else{return false}}).style("fill", function(d) { if(typeof color_2(d.user_count) !== 'undefined'){console.log("not undefined");return color_2(d.user_count);}else{console.log("undefined");return "#006d2c";};
		});}

		if(flag_2==1 && selectBar_2 != 1){
			console.log("building legend Data_2");
			buildLegend_2(data_2);
			
		}
	   
		if (isScrollDisplayed_2)
		{
			var xOverview_2 = d3.scale.ordinal()
		        .domain(data_2.map(function (d) { return d.user_id; }))
		        .rangeBands([0, width_2], .2);
			yOverview_2 = d3.scale.linear().range([heightOverview_2, 0]);
			yOverview_2.domain(yscale_2.domain());
			
			var subBars_2 = diagram_2.selectAll('.subBar_2')
		      .data(data_2)
		      

		  subBars_2.enter().append("rect")
		      .classed('subBar_2', true)
		      .classed("selectedSubBar_2",function(d,i){if(d.user_id==val_2 && i>6 && i<data_2.length-7){return true}else{return false;}})
		      .classed("lastSubBar_2",function(d,i){if(i==data_2.length-1){return true}else{return false;}})
		      .classed("firstSubBar_2",function(d,i){if(i==0){return true}else{return false;}})
		      .attr("x", function(d) {return xOverview_2(d.user_id);})
	           .attr("width", function(d) {return xOverview_2.rangeBand()})
	           .attr("y", function (d) { return height_2 + heightOverview_2 + yOverview_2(0); })
	           .attr("height", 0)
	           .transition().duration(function(d){if(flag_2!=1)return 1500;else return 0;})
	           .attr("y", function(d) {
	             return height_2 + heightOverview_2 + yOverview_2(d.user_count)
	         })
	           .attr("height", function(d) {
	             return heightOverview_2 - yOverview_2(d.user_count);
	         })
			
	 var displayed_2 = d3.scale.quantize()
	         .domain([0, width_2])
	         .range(d3.range(data_2.length+2));

	diagram_2.append("rect")
	         .attr("transform", "translate(0, " + (height_2 + margin_2.bottom) + ")")
	         .attr("class", "mover_2")
	         .attr("x", 0)
	         .attr("y", 0)
	         .attr("height", selectorHeight_2)
	         .attr("width", Math.round(parseFloat(numBars_2 * width_2)/data_2.length))
	         .attr("pointer-events", "all")
	         .attr("cursor", "ew-resize")
	         .call(d3.behavior.drag().on("drag", display_2));

	         console.log("float  " + Math.round(parseFloat(numBars_2 * width_2)/data_2.length)/2);

	   var rectWidth_2 = $('.subBar_2').width();
		
	   for(var checker_2 = 0; checker_2 < data_2.length; checker_2++){
	       if(data_2[checker_2].user_id==val_2){
	           if(checker_2>data_2.length-8){
	               moverToLast_2 = 1;
	               moverToFirst_2 = 0;
	               console.log("First if");
	           }else if(checker_2<7){
	               moverToLast_2 = 0;
	               moverToFirst_2 = 1;
	               console.log("Second if");
	           }else{
	               moverToFirst_2 = 0;
	               moverToLast_2 = 0;
	               console.log("Third if");
	           }
	       }
	       moverToFirst_2 = 1;
	   }

	   console.log("moverToLast_2 ",moverToLast_2);

	   firstSubBarLength_2 = $('.firstSubBar_2').offset().left - 8;

	   console.log("moverToFirst_2 "+moverToFirst_2);
	   
	   if(moverToLast_2 == 1){
	   	console.log("--------------------------------- _22222 IN 1");
	       console.log(rectWidth_2 + " rectWidth_2");
	       console.log($('.lastSubBar_2').offset().left + " $('.lastSubBar_2').offset().left");
	       of_2 = Math.round($('.lastSubBar_2').offset().left + rectWidth_2 - (parseFloat(numBars_2 * width_2)/data_2.length)) - firstSubBarLength_2;
	   }else if(moverToFirst_2 == 1){
	   	console.log("--------------------------------- _22222 IN 2");
	       of_2 = 0;
	   }else if((flag_2 == 1 || flag_2 == 0)&& moverToLast_2==1 && moverToFirst_2==1){
	   	console.log("--------------------------------- _22222 IN 3");
	   	of_2 = 0;
	   }else if(moverToLast_2==0 && moverToFirst_2==0 && selectBar_2!=1){
	   	console.log("--------------------------------- _22222 IN 4");
	   	of_2 = 0;
	   }else{
	   	console.log("--------------------------------- _22222 IN 5");
	   	of_2 = Math.round($('.selectedSubBar_2').offset().left - firstSubBarLength_2 - (parseFloat(numBars_2 * width_2)/data_2.length/2)) + rectWidth_2;
	   }      

	console.log("of_2 ",of_2) ;        

	if(selectBar_2==1){
	   d3.selectAll('.mover_2').attr("x",of_2);
	}else{
	   d3.selectAll(".subBar_2").classed("selectedSubBar_2",false);
	}

	compareData_2 = data_2;	
	}
		
		
	function display_2 () {
		d3.selectAll(".subBar_2").classed("selectedSubBar_2",false);

	    selectBar_2=0;
	    if(counter_2==0){
	        //buildBar_2(0,values_2,0,0);
	        counter_2 = 1;
	    }

	    //$("#userId").val($("#userId option:first").val());
	    //console.log("this is lead count "+user_count);
	    d3.selectAll(".bar_2").classed("disable",false);
	    var x_2 = parseInt(d3.select(this).attr("x")),
	        nx_2 = x_2 + d3.event.dx,
	        w_2 = parseInt(d3.select(this).attr("width")),
	        f_2, nf_2, new_data_2, rects_2;

	        //console.log("display x_2 :" + x_2);
	        //console.log("this is nx_2 "+nx_2);

	    if ( nx_2 < 0 || nx_2 + w_2 > width_2 ) return;

	    d3.select(this).attr("x", nx_2);

	    f_2 = displayed_2(x_2);
	    nf_2 = displayed_2(nx_2+1);
		
	    if ( f_2 === nf_2 ) return;


	    new_data_2 = data_2.slice(nf_2, nf_2 + numBars_2);
	    for(i=0;i<new_data_2.length;i++){
	        //console.log("new data_2 " + new_data_2[i].user_id);
	    }
	    

	    xscale_2.domain(new_data_2.map(function (d) { console.log("------"+ d.user_id);return d.user_id; }));
	    diagram_2.select(".x_2.axis_2").call(xAxis_2);

	    rects_2 = bars_2.selectAll("rect")
	      .data(new_data_2, function (d) {return d.user_id; });

		 	rects_2.attr("x", function (d) { console.log("------"+ xscale_2(d.user_id));return xscale_2(d.user_id); });

		 	 rects_2.enter().append("rect")
		      .attr("class", "bar_2")
		      .attr("x", function (d) { console.log(xscale_2(d.user_id));return xscale_2(d.user_id); })
		      .attr("y", function (d) { return yscale_2(d.user_count); })
		      .attr("width", xscale_2.rangeBand())
		      .attr("height", function (d) { return height_2 - yscale_2(d.user_count); })
			
		      
		      dataNumber_2	
				.data(new_data_2)
				.text(function(d){return d.user_count;})
				.attr("x", function(d) { return xscale_2(d.user_id) + (xscale_2.rangeBand()/2); })
				.attr("y",function(d){console.log("d.user_count ========== " + d.user_count);if(d.user_count!=0) return (yscale_2(d.user_count)-2); else return height_2;})
				.attr("font-family","sans-serif")
				.attr("font-size",10)
				.attr("fill",function(d){return "#000000";});

		      d3.selectAll("rect[class='bar_2']").on("mouseover", function(d) {      
		
		    	  d3.select(this).style("fill", function(){if(typeof color_2(d.user_count)!=='undefined'){console.log('undefined');return d3.rgb(color_2(d.user_count)).darker(2);}else{return '#003616';}});
		    	  barTooltip_2.transition()        
		    	    .duration(500)      
		    	    .style("opacity", .9);      

		    	var tip_2 = "<strong>User ID:</strong> " + d.user_id + "<br/>";
		    	var tip_2 = tip_2+"<strong>Deals:</strong> " + d.user_count+ "<br/>";

		    	barTooltip_2.html(tip_2)  
		    	    .style("left", (d3.event.pageX) + "px")     
		    	    .style("top", (d3.event.pageY - 28) + "px");    
		    	})                  
		    	.on("mouseout", function(d) {       
		    		 d3.select(this).style("fill", function(){if(typeof color_2(d.user_count)!=='undefined'){console.log('undefined');return d3.rgb(color_2(d.user_count));}else{return '#006d2c';}});	   
		    	barTooltip_2.transition()        
		    	    .duration(500)      
		    	    .style("opacity", 0);   
		    	});

		    	      rects_2.exit().remove();
		    	      d3.selectAll("rect[class='bar_2']").style("fill", function(d) { console.log("In Color Function::::::::::::::::::::--- "+color_2(d.user_count));if(typeof color_2(d.user_count)!=='undefined') {console.log("not undefined");return color_2(d.user_count);}else {console.log("undefined");return "rgb(0,109,44)";} })

		    	 
	    
		
		
	}
		
	function buildLegend_2(data_2){
		$('#barChartLegend_2').text('');

	    console.log("in bar legend");

		var margin_2 = {top: 0, right: 30, bottom: 10, left: 40},
		    width_2 = 800 - margin_2.left - margin_2.right,
		    height_2 = 200 - margin_2.top - margin_2.bottom;
		
		
		    var minProfit_2 = d3.min(data_2, function(d){ return d.user_count; });
			var maxProfit_2 = d3.max(data_2, function(d){ return d.user_count; });
		
		// console.log(minProfit);
		// console.log(maxProfit);
		
		var color_2 = d3.scale.quantize()
				.domain([minProfit_2, maxProfit_2])							
				.range(['rgb(165,15,21)','rgb(222,45,38)','rgb(251,106,74)','rgb(252,146,114)','rgb(252,187,161)','rgb(254,229,217)','rgb(227, 243, 240)','rgb(204,236,230)','rgb(153,216,201)','rgb(102,194,164)','rgb(44,162,95)','rgb(0,109,44)']);
		
		//sort values for color legend
		
		var barLegendData_2=[];
		data_2.forEach(function(dv){

		    var val_2 = parseFloat(dv.user_count)

		    if (val_2) {barLegendData_2.push(val_2);}

		});

		barLegendData_2.sort(function(a,b){ return a-b;});

		// console.log(barLegendData);

		var header_2 = d3.select("#barChartLegend_2")
		            .attr("width", 200)
		            .attr("height", 20)				  					
		            .attr("transform", "translate(" + 270 + "," + -175 + ")");

		        

		//add color legend
		header_2.selectAll(".barChartLegend_2")                        	
		    .data(barLegendData_2)
		    .enter()
		    .append("rect")
		    .attr({
		        x: function(d, i) {return i * (200/barLegendData_2.length);},
		        y: height_2+margin_2.top,
		        width: function(d,i){ return (200/barLegendData_2.length); },
		        height: 10,
		          fill: function(d) { if(typeof color_2(d) !== 'undefined')return color_2(d);else return "#006d2c";},		                           
		          class: "barChartLegend_2"
		       });
		
		header_2.append("text").text("Poor")
		    .attr({
		        x: 0,
		        y: height_2+24,
		        class: "poorLabel"				    			
		    });
		header_2.append("text").text("Good")
			.attr({
			x: 200-39,
			y: height_2+24,
			
			class: "goodLabel"				    			
			});
		
		
	}

	buildLegend_2(data_2);
		
	$('#barChartLegend_2').css("pointer-events","none");
		
		
		
	}
	
	
	
	
	
}


















/*	Second Bar Chart End	*/




</script>


<!-- First Bar Chart css -->


<script>

	$(window).bind("resize", function () {
	    console.log($(this).width())
	    if ($(this).width() < 1140) {
	        $('.item1').addClass('shadow');
	        $('.item2').addClass('shadow');
	        $('.grid-container').removeClass('shadow');
	    } else {
	    	$('.item1').removeClass('shadow');
	        $('.item2').removeClass('shadow');
	        $('.grid-container').addClass('shadow');
	    }
	}).trigger('resize');
</script>
	
<script>

var userId = $('#userId').val();
console.log("userId " + userId);
var projectId = $('#projectId').val();
console.log("projectId " + projectId);
var pied = $.ajax({
    type: "GET",
    contentType: "application/json; charset=utf-8",
    url: "${pageContext.request.contextPath}/getPieChart1Data",
    dataType: 'json',
    async:false,
    data : ({
		'userId':userId,
		'projectId':projectId
	}), 
    success: function (data) {
        return data;
    }
});

console.log("pieData Response " + pied.responseText);

pieData = JSON.parse(pied.responseText);



</script>
<script>
function pieColor(number){
	
	
	if(number==0)return "#2484c1";
	else if(number==1)return "#65a620";
	else if(number==2)return "#7b6888";
	else if(number==3)return "#a05d56";
	else if(number==4)return "#961a1a";
	else if(number==5)return "#d8d23a";
	else return "#635222";
}


var interval_3 = function(){
	$('#userId').val('');
	var userId = $('#userId').val();
	console.log("userId " + userId);
	$('#projectId').val('');
	var projectId = $('#projectId').val();
	console.log("projectId " + projectId);
	var pied = $.ajax({
	    type: "GET",
	    contentType: "application/json; charset=utf-8",
	    url: "${pageContext.request.contextPath}/getPieChart1Data",
	    dataType: 'json',
	    async:false,
	    data : ({
			'userId':userId,
			'projectId':projectId
		}), beforeSend:function(){
				
				$(function() {
				   var docHeight = $(document).height();

				   $("body").append("<div class='overlay'></div>");

				   $(".overlay")
				      .height(docHeight)
				      .css({
				         'opacity' : 0.7,
				         'position': 'fixed',
	  				         'top': 0,
	  				         'left': 0,
	  				         'right':0,
				         'background-color': 'black',
				         'width': '100%',
				         'z-index': 5000
				      });
			});	
				$('#image').css('z-index','6000');
			},
	    success: function (data) {
	        return data;
	    }
	});

	console.log("pieData3 Response " + pied.responseText);

	pieData3 = JSON.parse(pied.responseText);
	buildBarForPie(pieData3,1);
	buildPieChart(pieData3,0);
}

function buildBarForPie(values,flag){
	var data1 = Object.values(values[0]).slice(8,15);
	if(values.length == 0 || data1.every(item => item === 0)){
		$('#topChartPie').text('');
		var margin =  {top: 20, right: 20, bottom: 20, left: 40};
		var width = 500 - margin.left - margin.right;
		var height = 350 - margin.top - margin.bottom;
		
		var svg = d3.select("#topChartPie").append("svg")
		.attr("width", width + margin.left + margin.right)
		.attr("height", height + 35 + margin.top + margin.bottom )
		;
		
		var borderPath = svg.append("rect")
			.attr("x", 0)
			.attr("y", 0)
			.attr("height", height + 25 + margin.top + margin.bottom)
			.attr("width", width + margin.left + margin.right)
			.style("stroke", "#908d8d")
			.style("fill", "none")
			.style("stroke-width", 1);
		
		svg.append("rect")
			.attr("x", ((width + margin.left + margin.right)/2)-85)
			.attr("y",((height + 25 + margin.top + margin.bottom)/2)-25)
			.attr("width", 170)
			.attr("height", 50)
			.style("fill", "#908d8d")
			;
		
		svg.append("text")
			.attr("x", ((width + margin.left + margin.right)/2))
			.attr("y",((height + 25 + margin.top + margin.bottom)/2)+10)
			.text("No Data")
			.attr("width", 170)
			.attr("height", 50)
			.style("fill", "#ffffff")
			.attr("font-family","sans-serif")
			.attr("font-size",30)
			.attr("text-anchor","middle")
			;
		
		
		
		
	}else{
	$('#topChartPie').text('');
	
	var d = values;
	var data = Object.values(d[0]).slice(8,15);
	console.log("pie dataa "+data);
	var width = 500,
    	barHeight = 20;
	
	var x = d3.scale.linear()
    .range([0, width-80])
    .domain([0, d3.max(data, function(d) { return d; })])
    ;
	
	
	var svg = d3.select("#topChartPie").append("svg")
		.attr("width", width)
		.attr("height", barHeight * data.length)
		;
	
	var barTooltip = d3.select("#topChartPie").append("div")   
	    .attr("class", "tooltip")               
	    .style("opacity", 0);
	
	var barPieTitle = svg.selectAll(".barPieTitle")
	    .data(data)
	  	.enter().append("g")
	  	.classed("barPieTitle",true)
	   	.attr("transform", function(d, i) { return "translate(0," + i * barHeight + ")"; });
	
	barPieTitle.append("rect")
	    .attr("width", 40)
	    .attr("height", barHeight - 1)
	    .classed("barPieT",true)
	    .style("fill", "#dddfe0")
	    ;
	barPieTitle.append("text")
    .attr("x", function(d) { return 2; })
    .attr("y", barHeight / 2)
    .attr("dy", ".35em")
    .classed("headingBarPie",true)
    .text(function(d,i) { if(i==0)return "LB";else if(i==1)return "C/N";else if(i==2)return "LQ";else if(i==3)return "WON";else if(i==4)return "SV";else if(i==5)return "FU";else if(i==6)return "LOST"; })
    .style("font-size","13px")
    .style("font-family","sans-serif")
    ;
	
	var barPie = svg.selectAll(".barPie")
	    .data(data)
	  	.enter().append("g")
	  	.classed("barPie",true)
	   	.attr("transform", function(d, i) { return "translate(40," + i * barHeight + ")"; });
	/*
	
	*/
	
	var val=-1;
	
	barPie.append("rect")
		.attr("width", 0)
		.attr("height", barHeight - 1)
	    .classed("orgBar",true)
		.style("fill", function(d,i){if(d!=0){ return pieColor(++val); }})

	    .transition().duration(function(){if(flag!=1)return 2000; else return 0;})
		.ease("cubic")
	    .attr("width", function(d) { return x(d); })
	    ;

	
	barPie.append("text")
	    .attr("x", 0)
	    .attr("y", barHeight / 2)
	    .attr("dy", ".35em")
	    .classed("valueBarPie",true)
	    .text(function(d) { return d; })
	    .transition().duration(function(){if(flag!=1)return 2000; else return 0;})
		.ease("cubic")
	    .attr("x", function(d) { return x(d)+2  })
	    ;
	var val2 = -1;
	d3.selectAll(".barPie rect").on("mouseover", function(d,i) {      
	    
	barTooltip.transition()        
	    .duration(500)      
	    .style("opacity", .9);      


	var tip = "";
	if(i==0)
	 tip = "<strong>Lead Bucket:</strong> " + d+ "<br/>";
	else if(i==1)
	 tip = "<strong>Call/Negotiation:</strong> " + d+ "<br/>";
	else if(i==2)
	 tip = "<strong>Lead Qualified:</strong> " + d+ "<br/>";
	else if(i==3)
	 tip = "<strong>Sale Won:</strong> " + d+ "<br/>";
	 else if(i==4)
		 tip = "<strong>Site Visit:</strong> " + d+ "<br/>";
	 else if(i==5)
		 tip = "<strong>Follow Up:</strong> " + d+ "<br/>";
	 else if(i==6)
		 tip = "<strong>Sale Lost:</strong> " + d+ "<br/>";


	barTooltip.html(tip)  
	    .style("left", (d3.event.pageX) + "px")     
	    .style("top", (d3.event.pageY - 28) + "px");    
	})                  
	.on("mouseout", function(d,i) {       

		
	barTooltip.transition()        
	    .duration(500)      
	    .style("opacity", 0);   
	});

	}	
}

buildBarForPie(pieData,0);
</script>
<style>



.valueBarPie {
  fill: black;
  font: 10px sans-serif;
}
.headingBarPie{
	fill:#313131;
}

</style>
<script>
var prevValue;
function buildPieChart(values,flag){
	var data1 = Object.values(values[0]).slice(8,15);
	if(values.length == 0 || data1.every(item => item === 0)){
		$('#pie').text('');
		var margin =  {top: 20, right: 20, bottom: 20, left: 40};
		var width = 500 - margin.left - margin.right;
		var height = 350 - margin.top - margin.bottom;
		
		var svg = d3.select("#pie").append("svg")
		.attr("width", width + margin.left + margin.right)
		.attr("height", height + 35 + margin.top + margin.bottom )
		;
		
		var borderPath = svg.append("rect")
			.attr("x", 0)
			.attr("y", 0)
			.attr("height", height + 25 + margin.top + margin.bottom)
			.attr("width", width + margin.left + margin.right)
			.style("stroke", "#908d8d")
			.style("fill", "none")
			.style("stroke-width", 1);
		
		svg.append("rect")
			.attr("x", ((width + margin.left + margin.right)/2)-85)
			.attr("y",((height + 25 + margin.top + margin.bottom)/2)-25)
			.attr("width", 170)
			.attr("height", 50)
			.style("fill", "#908d8d")
			;
		
		svg.append("text")
			.attr("x", ((width + margin.left + margin.right)/2))
			.attr("y",((height + 25 + margin.top + margin.bottom)/2)+10)
			.text("No Data")
			.attr("width", 170)
			.attr("height", 50)
			.style("fill", "#ffffff")
			.attr("font-family","sans-serif")
			.attr("font-size",30)
			.attr("text-anchor","middle")
			;
		
		
		
		
	}else{
		//alert(JSON.stringify(prevValue));
	if(JSON.stringify(values)==JSON.stringify(prevValue)){
		
	}
	else{
		$('#pieDes').text('');
		$('#pie').text('');
		/////////////////////////////////////////////////////////////////////////////////
		/*	Script Start	*/
// NOTE: dont read this script upto(Script End) if you dont want to, it is downloaded, (d3pie.js)		
		(function(root, factory) {
			  if (typeof define === 'function' && define.amd) {
			    // AMD. Register as an anonymous module
			    define([], factory);
			  } else if (typeof exports === 'object') {
			    // Node. Does not work with strict CommonJS, but only CommonJS-like environments that support module.exports,
			    // like Node
			    module.exports = factory();
			  } else {
			    // browser globals (root is window)
			    root.d3pie = factory(root);
			  }
			}(this, function() {

				var _scriptName = "d3pie";
				var _version = "0.1.6";

				// used to uniquely generate IDs and classes, ensuring no conflict between multiple pies on the same page
				var _uniqueIDCounter = 0;


				// this section includes all helper libs on the d3pie object. They're populated via grunt-template. Note: to keep
				// the syntax highlighting from getting all messed up, I commented out each line. That REQUIRES each of the files
				// to have an empty first line. Crumby, yes, but acceptable.
				//// --------- _default-settings.js -----------/**
			/**
			 * Contains the out-the-box settings for the script. Any of these settings that aren't explicitly overridden for the
			 * d3pie instance will inherit from these. This is also included on the main website for use in the generation script.
			 */
			var defaultSettings = {
				header: {
					title: {
						text:     "",
						color:    "#333333",
						fontSize: 18,
						font:     "arial"
					},
					subtitle: {
						text:     "",
						color:    "#666666",
						fontSize: 14,
						font:     "arial"
					},
					location: "top-center",
					titleSubtitlePadding: 8
				},
				footer: {
					text: 	  "",
					color:    "#666666",
					fontSize: 14,
					font:     "arial",
					location: "left"
				},
				size: {
					canvasHeight: 300,
					canvasWidth: 500,
					pieInnerRadius: "0%",
					pieOuterRadius: null
				},
				data: {
					sortOrder: "none",
					ignoreSmallSegments: {
						enabled: false,
						valueType: "percentage",
						value: null
					},
					smallSegmentGrouping: {
						enabled: false,
						value: 1,
						valueType: "percentage",
						label: "Other",
						color: "#cccccc"
					},
					content: []
				},
				labels: {
					outer: {
						format: "label",
						hideWhenLessThanPercentage: null,
						pieDistance: 30
					},
					inner: {
						format: "percentage",
						hideWhenLessThanPercentage: null
					},
					mainLabel: {
						color: "#333333",
						font: "arial",
						fontSize: 10
					},
					percentage: {
						color: "#dddddd",
						font: "arial",
						fontSize: 10,
						decimalPlaces: 0
					},
					value: {
						color: "#cccc44",
						font: "arial",
						fontSize: 10
					},
					lines: {
						enabled: true,
						style: "curved",
						color: "segment"
					},
					truncation: {
						enabled: false,
						truncateLength: 30
					},
			    formatter: null
				},
				effects: {
					load: {
						effect: "default",
						speed: 1000
					},
					pullOutSegmentOnClick: {
						effect: "bounce",
						speed: 300,
						size: 10
					},
					highlightSegmentOnMouseover: true,
					highlightLuminosity: -0.2
				},
				tooltips: {
					enabled: false,
					type: "placeholder", // caption|placeholder
			    string: "",
			    placeholderParser: null,
					styles: {
			      fadeInSpeed: 250,
						backgroundColor: "#000000",
			      backgroundOpacity: 0.5,
						color: "#efefef",
			      borderRadius: 2,
			      font: "arial",
			      fontSize: 10,
			      padding: 4
					}
				},
				misc: {
					colors: {
						background: null,
						segments: [
							"#2484c1", "#65a620", "#7b6888", "#a05d56", "#961a1a", "#d8d23a", "#635222", "#d0743c", "#e98125", "#6ada6a",
							"#0c6197", "#7d9058", "#207f33", "#44b9b0", "#bca44a", "#e4a14b", "#a3acb2", "#8cc3e9", "#69a6f9", "#5b388f",
							"#546e91", "#8bde95", "#d2ab58", "#273c71", "#98bf6e", "#4daa4b", "#98abc5", "#cc1010", "#31383b", "#006391",
							"#c2643f", "#b0a474", "#a5a39c", "#a9c2bc", "#22af8c", "#7fcecf", "#987ac6", "#3d3b87", "#b77b1c", "#c9c2b6",
							"#807ece", "#8db27c", "#be66a2", "#9ed3c6", "#00644b", "#005064", "#77979f", "#77e079", "#9c73ab", "#1f79a7"
						],
						segmentStroke: "#ffffff"
					},
					gradient: {
						enabled: false,
						percentage: 95,
						color: "#000000"
					},
					canvasPadding: {
						top: 5,
						right: 5,
						bottom: 5,
						left: 5
					},
					pieCenterOffset: {
						x: 0,
						y: 0
					},
					cssPrefix: null
				},
				callbacks: {
					onload: null,
					onMouseoverSegment: null,
					onMouseoutSegment: null,
					onClickSegment: null
				}
			};

				//// --------- validate.js -----------
			var validate = {

				// called whenever a new pie chart is created
				initialCheck: function(pie) {
					var cssPrefix = pie.cssPrefix;
					var element = pie.element;
					var options = pie.options;

					// confirm d3 is available [check minimum version]
					if (!window.d3 || !window.d3.hasOwnProperty("version")) {
						console.error("d3pie error: d3 is not available");
						return false;
					}

					// confirm element is either a DOM element or a valid string for a DOM element
					if (!(element instanceof HTMLElement || element instanceof SVGElement)) {
						console.error("d3pie error: the first d3pie() param must be a valid DOM element (not jQuery) or a ID string.");
						return false;
					}

					// confirm the CSS prefix is valid. It has to start with a-Z and contain nothing but a-Z0-9_-
					if (!(/[a-zA-Z][a-zA-Z0-9_-]*$/.test(cssPrefix))) {
						console.error("d3pie error: invalid options.misc.cssPrefix");
						return false;
					}

					// confirm some data has been supplied
					if (!helpers.isArray(options.data.content)) {
						console.error("d3pie error: invalid config structure: missing data.content property.");
						return false;
					}
					if (options.data.content.length === 0) {
						console.error("d3pie error: no data supplied.");
						return false;
					}

					// clear out any invalid data. Each data row needs a valid positive number and a label
					var data = [];
					for (var i=0; i<options.data.content.length; i++) {
						if (typeof options.data.content[i].value !== "number" || isNaN(options.data.content[i].value)) {
							console.log("not valid: ", options.data.content[i]);
							continue;
						}
						if (options.data.content[i].value <= 0) {
							console.log("not valid - should have positive value: ", options.data.content[i]);
							continue;
						}
						data.push(options.data.content[i]);
					}
					pie.options.data.content = data;

					// labels.outer.hideWhenLessThanPercentage - 1-100
					// labels.inner.hideWhenLessThanPercentage - 1-100

					return true;
				}
			};

				//// --------- helpers.js -----------
			var helpers = {

				// creates the SVG element
				addSVGSpace: function(pie) {
					var element = pie.element;
					var canvasWidth = pie.options.size.canvasWidth;
					var canvasHeight = pie.options.size.canvasHeight;
					var backgroundColor = pie.options.misc.colors.background;

					var svg = d3.select(element).append("svg:svg")
						.attr("width", canvasWidth)
						.attr("height", canvasHeight);

					if (backgroundColor !== "transparent") {
						svg.style("background-color", function() { return backgroundColor; });
					}

					return svg;
				},

				whenIdExists: function(id, callback) {
					var inc = 1;
					var giveupIterationCount = 1000;

					var interval = setInterval(function() {
						if (document.getElementById(id)) {
							clearInterval(interval);
							callback();
						}
						if (inc > giveupIterationCount) {
							clearInterval(interval);
						}
						inc++;
					}, 1);
				},

				whenElementsExist: function(els, callback) {
					var inc = 1;
					var giveupIterationCount = 1000;

					var interval = setInterval(function() {
						var allExist = true;
						for (var i=0; i<els.length; i++) {
							if (!document.getElementById(els[i])) {
								allExist = false;
								break;
							}
						}
						if (allExist) {
							clearInterval(interval);
							callback();
						}
						if (inc > giveupIterationCount) {
							clearInterval(interval);
						}
						inc++;
					}, 1);
				},

				shuffleArray: function(array) {
					var currentIndex = array.length, tmpVal, randomIndex;

					while (0 !== currentIndex) {
						randomIndex = Math.floor(Math.random() * currentIndex);
						currentIndex -= 1;

						// and swap it with the current element
						tmpVal = array[currentIndex];
						array[currentIndex] = array[randomIndex];
						array[randomIndex] = tmpVal;
					}
					return array;
				},

				processObj: function(obj, is, value) {
					if (typeof is === 'string') {
						return helpers.processObj(obj, is.split('.'), value);
					} else if (is.length === 1 && value !== undefined) {
			            obj[is[0]] = value;
						return obj[is[0]];
					} else if (is.length === 0) {
						return obj;
					} else {
						return helpers.processObj(obj[is[0]], is.slice(1), value);
					}
				},

				getDimensions: function(id) {
					var el = document.getElementById(id);
					var w = 0, h = 0;
					if (el) {
						var dimensions = el.getBBox();
						w = dimensions.width;
						h = dimensions.height;
					} else {
						console.log("error: getDimensions() " + id + " not found.");
					}
					return { w: w, h: h };
				},

				/**
				 * This is based on the SVG coordinate system, where top-left is 0,0 and bottom right is n-n.
				 * @param r1
				 * @param r2
				 * @returns {boolean}
				 */
				rectIntersect: function(r1, r2) {
					var returnVal = (
						// r2.left > r1.right
						(r2.x > (r1.x + r1.w)) ||

						// r2.right < r1.left
						((r2.x + r2.w) < r1.x) ||

						// r2.top < r1.bottom
						((r2.y + r2.h) < r1.y) ||

						// r2.bottom > r1.top
						(r2.y > (r1.y + r1.h))
					);

					return !returnVal;
				},

				/**
				 * Returns a lighter/darker shade of a hex value, based on a luminance value passed.
				 * @param hex a hex color value such as #abc or #123456 (the hash is optional)
				 * @param lum the luminosity factor: -0.1 is 10% darker, 0.2 is 20% lighter, etc.
				 * @returns {string}
				 */
				getColorShade: function(hex, lum) {

					// validate hex string
					hex = String(hex).replace(/[^0-9a-f]/gi, '');
					if (hex.length < 6) {
						hex = hex[0]+hex[0]+hex[1]+hex[1]+hex[2]+hex[2];
					}
					lum = lum || 0;

					// convert to decimal and change luminosity
					var newHex = "#";
					for (var i=0; i<3; i++) {
						var c = parseInt(hex.substr(i * 2, 2), 16);
						c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
						newHex += ("00" + c).substr(c.length);
					}

					return newHex;
				},

				/**
				 * Users can choose to specify segment colors in three ways (in order of precedence):
				 * 	1. include a "color" attribute for each row in data.content
				 * 	2. include a misc.colors.segments property which contains an array of hex codes
				 * 	3. specify nothing at all and rely on this lib provide some reasonable defaults
				 *
				 * This function sees what's included and populates this.options.colors with whatever's required
				 * for this pie chart.
				 * @param data
				 */
				initSegmentColors: function(pie) {
					var data   = pie.options.data.content;
					var colors = pie.options.misc.colors.segments;

					// TODO this needs a ton of error handling

					var finalColors = [];
					for (var i=0; i<data.length; i++) {
						if (data[i].hasOwnProperty("color")) {
							finalColors.push(data[i].color);
						} else {
							finalColors.push(colors[i]);
						}
					}

					return finalColors;
				},

				applySmallSegmentGrouping: function(data, smallSegmentGrouping) {
					var totalSize;
					if (smallSegmentGrouping.valueType === "percentage") {
						totalSize = math.getTotalPieSize(data);
					}

					// loop through each data item
					var newData = [];
					var groupedData = [];
					var totalGroupedData = 0;
					for (var i=0; i<data.length; i++) {
						if (smallSegmentGrouping.valueType === "percentage") {
							var dataPercent = (data[i].value / totalSize) * 100;
							if (dataPercent <= smallSegmentGrouping.value) {
								groupedData.push(data[i]);
								totalGroupedData += data[i].value;
								continue;
							}
							data[i].isGrouped = false;
							newData.push(data[i]);
						} else {
							if (data[i].value <= smallSegmentGrouping.value) {
								groupedData.push(data[i]);
								totalGroupedData += data[i].value;
								continue;
							}
							data[i].isGrouped = false;
							newData.push(data[i]);
						}
					}

					// we're done! See if there's any small segment groups to add
					if (groupedData.length) {
						newData.push({
							color: smallSegmentGrouping.color,
							label: smallSegmentGrouping.label,
							value: totalGroupedData,
							isGrouped: true,
							groupedData: groupedData
						});
					}

					return newData;
				},

				// for debugging
				showPoint: function(svg, x, y) {
					svg.append("circle").attr("cx", x).attr("cy", y).attr("r", 2).style("fill", "black");
				},

				isFunction: function(functionToCheck) {
					var getType = {};
					return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
				},

				isArray: function(o) {
					return Object.prototype.toString.call(o) === '[object Array]';
				}
			};


			// taken from jQuery
			var extend = function() {
				var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
					i = 1,
					length = arguments.length,
					deep = false,
					toString = Object.prototype.toString,
					hasOwn = Object.prototype.hasOwnProperty,
					class2type = {
						"[object Boolean]": "boolean",
						"[object Number]": "number",
						"[object String]": "string",
						"[object Function]": "function",
						"[object Array]": "array",
						"[object Date]": "date",
						"[object RegExp]": "regexp",
						"[object Object]": "object"
					},

					jQuery = {
						isFunction: function (obj) {
							return jQuery.type(obj) === "function";
						},
						isArray: Array.isArray ||
							function (obj) {
								return jQuery.type(obj) === "array";
							},
						isWindow: function (obj) {
							return obj !== null && obj === obj.window;
						},
						isNumeric: function (obj) {
							return !isNaN(parseFloat(obj)) && isFinite(obj);
						},
						type: function (obj) {
							return obj === null ? String(obj) : class2type[toString.call(obj)] || "object";
						},
						isPlainObject: function (obj) {
							if (!obj || jQuery.type(obj) !== "object" || obj.nodeType) {
								return false;
							}
							try {
								if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype, "isPrototypeOf")) {
									return false;
								}
							} catch (e) {
								return false;
							}
							var key;
							for (key in obj) {}
							return key === undefined || hasOwn.call(obj, key);
						}
					};
				if (typeof target === "boolean") {
					deep = target;
					target = arguments[1] || {};
					i = 2;
				}
				if (typeof target !== "object" && !jQuery.isFunction(target)) {
					target = {};
				}
				if (length === i) {
					target = this;
					--i;
				}
				for (i; i < length; i++) {
					if ((options = arguments[i]) !== null) {
						for (name in options) {
							src = target[name];
							copy = options[name];
							if (target === copy) {
								continue;
							}
							if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
								if (copyIsArray) {
									copyIsArray = false;
									clone = src && jQuery.isArray(src) ? src : [];
								} else {
									clone = src && jQuery.isPlainObject(src) ? src : {};
								}
								// WARNING: RECURSION
								target[name] = extend(deep, clone, copy);
							} else if (copy !== undefined) {
								target[name] = copy;
							}
						}
					}
				}
				return target;
			};
				//// --------- math.js -----------
			var math = {

				toRadians: function(degrees) {
					return degrees * (Math.PI / 180);
				},

				toDegrees: function(radians) {
					return radians * (180 / Math.PI);
				},

				computePieRadius: function(pie) {
					var size = pie.options.size;
					var canvasPadding = pie.options.misc.canvasPadding;

					// outer radius is either specified (e.g. through the generator), or omitted altogether
					// and calculated based on the canvas dimensions. Right now the estimated version isn't great - it should
					// be possible to calculate it to precisely generate the maximum sized pie, but it's fussy as heck. Something
					// for the next release.

					// first, calculate the default _outerRadius
					var w = size.canvasWidth - canvasPadding.left - canvasPadding.right;
					var h = size.canvasHeight - canvasPadding.top - canvasPadding.bottom;

					// now factor in the footer, title & subtitle
			    if (pie.options.header.location !== "pie-center") {
			      h -= pie.textComponents.headerHeight;
			    }

			    if (pie.textComponents.footer.exists) {
			      h -= pie.textComponents.footer.h;
			    }

					// for really teeny pies, h may be < 0. Adjust it back
					h = (h < 0) ? 0 : h;

					var outerRadius = ((w < h) ? w : h) / 3;
					var innerRadius, percent;

					// if the user specified something, use that instead
					if (size.pieOuterRadius !== null) {
						if (/%/.test(size.pieOuterRadius)) {
							percent = parseInt(size.pieOuterRadius.replace(/[\D]/, ""), 10);
							percent = (percent > 99) ? 99 : percent;
							percent = (percent < 0) ? 0 : percent;

							var smallestDimension = (w < h) ? w : h;

							// now factor in the label line size
							if (pie.options.labels.outer.format !== "none") {
								var pieDistanceSpace = parseInt(pie.options.labels.outer.pieDistance, 10) * 2;
								if (smallestDimension - pieDistanceSpace > 0) {
									smallestDimension -= pieDistanceSpace;
								}
							}

							outerRadius = Math.floor((smallestDimension / 100) * percent) / 2;
						} else {
							outerRadius = parseInt(size.pieOuterRadius, 10);
						}
					}

					// inner radius
					if (/%/.test(size.pieInnerRadius)) {
						percent = parseInt(size.pieInnerRadius.replace(/[\D]/, ""), 10);
						percent = (percent > 99) ? 99 : percent;
						percent = (percent < 0) ? 0 : percent;
						innerRadius = Math.floor((outerRadius / 100) * percent);
					} else {
						innerRadius = parseInt(size.pieInnerRadius, 10);
					}

					pie.innerRadius = innerRadius;
					pie.outerRadius = outerRadius;
				},

				getTotalPieSize: function(data) {
					var totalSize = 0;
					for (var i=0; i<data.length; i++) {
						totalSize += data[i].value;
					}
					return totalSize;
				},

				sortPieData: function(pie) {
					var data                 = pie.options.data.content;
					var sortOrder            = pie.options.data.sortOrder;

					switch (sortOrder) {
						case "none":
							// do nothing
							break;
						case "random":
							data = helpers.shuffleArray(data);
							break;
						case "value-asc":
							data.sort(function(a, b) { return (a.value < b.value) ? -1 : 1; });
							break;
						case "value-desc":
							data.sort(function(a, b) { return (a.value < b.value) ? 1 : -1; });
							break;
						case "label-asc":
							data.sort(function(a, b) { return (a.label.toLowerCase() > b.label.toLowerCase()) ? 1 : -1; });
							break;
						case "label-desc":
							data.sort(function(a, b) { return (a.label.toLowerCase() < b.label.toLowerCase()) ? 1 : -1; });
							break;
					}

					return data;
				},

				

				// var pieCenter = math.getPieCenter();
				getPieTranslateCenter: function(pieCenter) {
					return "translate(" + pieCenter.x + "," + pieCenter.y + ")";
				},

				/**
				 * Used to determine where on the canvas the center of the pie chart should be. It takes into account the
				 * height and position of the title, subtitle and footer, and the various paddings.
				 * @private
				 */
				calculatePieCenter: function(pie) {
					var pieCenterOffset = pie.options.misc.pieCenterOffset;
					var hasTopTitle    = (pie.textComponents.title.exists && pie.options.header.location !== "pie-center");
					var hasTopSubtitle = (pie.textComponents.subtitle.exists && pie.options.header.location !== "pie-center");

					var headerOffset = pie.options.misc.canvasPadding.top;
					if (hasTopTitle && hasTopSubtitle) {
						headerOffset += pie.textComponents.title.h + pie.options.header.titleSubtitlePadding + pie.textComponents.subtitle.h;
					} else if (hasTopTitle) {
						headerOffset += pie.textComponents.title.h;
					} else if (hasTopSubtitle) {
						headerOffset += pie.textComponents.subtitle.h;
					}

					var footerOffset = 0;
					if (pie.textComponents.footer.exists) {
						footerOffset = pie.textComponents.footer.h + pie.options.misc.canvasPadding.bottom;
					}

					var x = ((pie.options.size.canvasWidth - pie.options.misc.canvasPadding.left - pie.options.misc.canvasPadding.right) / 2) + pie.options.misc.canvasPadding.left;
					var y = ((pie.options.size.canvasHeight - footerOffset - headerOffset) / 2) + headerOffset;

					x += pieCenterOffset.x;
					y += pieCenterOffset.y;

					pie.pieCenter = { x: x, y: y };
				},


				/**
				 * Rotates a point (x, y) around an axis (xm, ym) by degrees (a).
				 * @param x
				 * @param y
				 * @param xm
				 * @param ym
				 * @param a angle in degrees
				 * @returns {Array}
				 */
				rotate: function(x, y, xm, ym, a) {

			        a = a * Math.PI / 180; // convert to radians

			        var cos = Math.cos,
						sin = Math.sin,
					// subtract midpoints, so that midpoint is translated to origin and add it in the end again
					xr = (x - xm) * cos(a) - (y - ym) * sin(a) + xm,
					yr = (x - xm) * sin(a) + (y - ym) * cos(a) + ym;

					return { x: xr, y: yr };
				},

				/**
				 * Translates a point x, y by distance d, and by angle a.
				 * @param x
				 * @param y
				 * @param dist
				 * @param a angle in degrees
				 */
				translate: function(x, y, d, a) {
					var rads = math.toRadians(a);
					return {
						x: x + d * Math.sin(rads),
						y: y - d * Math.cos(rads)
					};
				},

				// from: http://stackoverflow.com/questions/19792552/d3-put-arc-labels-in-a-pie-chart-if-there-is-enough-space
				pointIsInArc: function(pt, ptData, d3Arc) {
					// Center of the arc is assumed to be 0,0
					// (pt.x, pt.y) are assumed to be relative to the center
					var r1 = d3Arc.innerRadius()(ptData), // Note: Using the innerRadius
						r2 = d3Arc.outerRadius()(ptData),
						theta1 = d3Arc.startAngle()(ptData),
						theta2 = d3Arc.endAngle()(ptData);

					var dist = pt.x * pt.x + pt.y * pt.y,
						angle = Math.atan2(pt.x, -pt.y); // Note: different coordinate system

					angle = (angle < 0) ? (angle + Math.PI * 2) : angle;

					return (r1 * r1 <= dist) && (dist <= r2 * r2) &&
						(theta1 <= angle) && (angle <= theta2);
				}
			};

				//// --------- labels.js -----------
			var labels = {

				/**
				 * Adds the labels to the pie chart, but doesn't position them. There are two locations for the
				 * labels: inside (center) of the segments, or outside the segments on the edge.
				 * @param section "inner" or "outer"
				 * @param sectionDisplayType "percentage", "value", "label", "label-value1", etc.
				 * @param pie
				 */
				add: function(pie, section, sectionDisplayType) {
					var include = labels.getIncludes(sectionDisplayType);
					var settings = pie.options.labels;

					// group the label groups (label, percentage, value) into a single element for simpler positioning
					var outerLabel = pie.svg.insert("g", "." + pie.cssPrefix + "labels-" + section)
						.attr("class", pie.cssPrefix + "labels-" + section);

					var labelGroup = outerLabel.selectAll("." + pie.cssPrefix + "labelGroup-" + section)
						.data(pie.options.data.content)
						.enter()
						.append("g")
						.attr("id", function(d, i) { return pie.cssPrefix + "labelGroup" + i + "-" + section; })
						.attr("data-index", function(d, i) { return i; })
						.attr("class", pie.cssPrefix + "labelGroup-" + section)
						.style("opacity", 0);

			    var formatterContext = { section: section, sectionDisplayType: sectionDisplayType };

					// 1. Add the main label
					if (include.mainLabel) {
						labelGroup.append("text")
							.attr("id", function(d, i) { return pie.cssPrefix + "segmentMainLabel" + i + "-" + section; })
							.attr("class", pie.cssPrefix + "segmentMainLabel-" + section)
							.text(function(d, i) {
								var str = d.label;

			          // if a custom formatter has been defined, pass it the raw label string - it can do whatever it wants with it.
			          // we only apply truncation if it's not defined
								if (settings.formatter) {
			            formatterContext.index = i;
			            formatterContext.part = 'mainLabel';
			            formatterContext.value = d.value;
			            formatterContext.label = str;
			            str = settings.formatter(formatterContext);
			          } else if (settings.truncation.enabled && d.label.length > settings.truncation.truncateLength) {
			            str = d.label.substring(0, settings.truncation.truncateLength) + "...";
			          }
			          return str;
							})
							.style("font-size", settings.mainLabel.fontSize + "px")
							.style("font-family", settings.mainLabel.font)
							.style("fill", settings.mainLabel.color);
					}

					// 2. Add the percentage label
					if (include.percentage) {
						labelGroup.append("text")
							.attr("id", function(d, i) { return pie.cssPrefix + "segmentPercentage" + i + "-" + section; })
							.attr("class", pie.cssPrefix + "segmentPercentage-" + section)
							.text(function(d, i) {
								var percentage = segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces);
			          if (settings.formatter) {
			            formatterContext.index = i;
			            formatterContext.part = "percentage";
			            formatterContext.value = d.value;
			            formatterContext.label = percentage;
			            percentage = settings.formatter(formatterContext);
			          } else {
			            percentage += "%";
			          }
			          return percentage;
							})
							.style("font-size", settings.percentage.fontSize + "px")
							.style("font-family", settings.percentage.font)
							.style("fill", settings.percentage.color);
					}

					// 3. Add the value label
					if (include.value) {
						labelGroup.append("text")
							.attr("id", function(d, i) { return pie.cssPrefix +  "segmentValue" + i + "-" + section; })
							.attr("class", pie.cssPrefix + "segmentValue-" + section)
							.text(function(d, i) {
			          formatterContext.index = i;
			          formatterContext.part = "value";
			          formatterContext.value = d.value;
			          formatterContext.label = d.value;
			          return settings.formatter ? settings.formatter(formatterContext, d.value) : d.value;
			        })
							.style("font-size", settings.value.fontSize + "px")
							.style("font-family", settings.value.font)
							.style("fill", settings.value.color);
					}
				},

				/**
				 * @param section "inner" / "outer"
				 */
				positionLabelElements: function(pie, section, sectionDisplayType) {
					labels["dimensions-" + section] = [];

					// get the latest widths, heights
					var labelGroups = d3.selectAll("." + pie.cssPrefix + "labelGroup-" + section);
					labelGroups.each(function(d, i) {
						var mainLabel  = d3.select(this).selectAll("." + pie.cssPrefix + "segmentMainLabel-" + section);
						var percentage = d3.select(this).selectAll("." + pie.cssPrefix + "segmentPercentage-" + section);
						var value      = d3.select(this).selectAll("." + pie.cssPrefix + "segmentValue-" + section);

						labels["dimensions-" + section].push({
							mainLabel:  (mainLabel.node() !== null) ? mainLabel.node().getBBox() : null,
							percentage: (percentage.node() !== null) ? percentage.node().getBBox() : null,
							value:      (value.node() !== null) ? value.node().getBBox() : null
						});
					});

					var singleLinePad = 5;
					var dims = labels["dimensions-" + section];
					switch (sectionDisplayType) {
						case "label-value1":
							d3.selectAll("." + pie.cssPrefix + "segmentValue-" + section)
								.attr("dx", function(d, i) { return dims[i].mainLabel.width + singleLinePad; });
							break;
						case "label-value2":
							d3.selectAll("." + pie.cssPrefix + "segmentValue-" + section)
								.attr("dy", function(d, i) { return dims[i].mainLabel.height; });
							break;
						case "label-percentage1":
							d3.selectAll("." + pie.cssPrefix + "segmentPercentage-" + section)
								.attr("dx", function(d, i) { return dims[i].mainLabel.width + singleLinePad; });
							break;
						case "label-percentage2":
							d3.selectAll("." + pie.cssPrefix + "segmentPercentage-" + section)
								.attr("dx", function(d, i) { return (dims[i].mainLabel.width / 2) - (dims[i].percentage.width / 2); })
								.attr("dy", function(d, i) { return dims[i].mainLabel.height; });
							break;
				 	}
				},

				computeLabelLinePositions: function(pie) {
					pie.lineCoordGroups = [];
					d3.selectAll("." + pie.cssPrefix + "labelGroup-outer")
						.each(function(d, i) { return labels.computeLinePosition(pie, i); });
				},

				computeLinePosition: function(pie, i) {
					var angle = segments.getSegmentAngle(i, pie.options.data.content, pie.totalSize, { midpoint: true });
					var originCoords = math.rotate(pie.pieCenter.x, pie.pieCenter.y - pie.outerRadius, pie.pieCenter.x, pie.pieCenter.y, angle);
					var heightOffset = pie.outerLabelGroupData[i].h / 5; // TODO check
					var labelXMargin = 6; // the x-distance of the label from the end of the line [TODO configurable]

					var quarter = Math.floor(angle / 90);
					var midPoint = 4;
					var x2, y2, x3, y3;

					// this resolves an issue when the
					if (quarter === 2 && angle === 180) {
						quarter = 1;
					}

					switch (quarter) {
						case 0:
							x2 = pie.outerLabelGroupData[i].x - labelXMargin - ((pie.outerLabelGroupData[i].x - labelXMargin - originCoords.x) / 2);
							y2 = pie.outerLabelGroupData[i].y + ((originCoords.y - pie.outerLabelGroupData[i].y) / midPoint);
							x3 = pie.outerLabelGroupData[i].x - labelXMargin;
							y3 = pie.outerLabelGroupData[i].y - heightOffset;
							break;
						case 1:
							x2 = originCoords.x + (pie.outerLabelGroupData[i].x - originCoords.x) / midPoint;
							y2 = originCoords.y + (pie.outerLabelGroupData[i].y - originCoords.y) / midPoint;
							x3 = pie.outerLabelGroupData[i].x - labelXMargin;
							y3 = pie.outerLabelGroupData[i].y - heightOffset;
							break;
						case 2:
							var startOfLabelX = pie.outerLabelGroupData[i].x + pie.outerLabelGroupData[i].w + labelXMargin;
							x2 = originCoords.x - (originCoords.x - startOfLabelX) / midPoint;
							y2 = originCoords.y + (pie.outerLabelGroupData[i].y - originCoords.y) / midPoint;
							x3 = pie.outerLabelGroupData[i].x + pie.outerLabelGroupData[i].w + labelXMargin;
							y3 = pie.outerLabelGroupData[i].y - heightOffset;
							break;
						case 3:
							var startOfLabel = pie.outerLabelGroupData[i].x + pie.outerLabelGroupData[i].w + labelXMargin;
							x2 = startOfLabel + ((originCoords.x - startOfLabel) / midPoint);
							y2 = pie.outerLabelGroupData[i].y + (originCoords.y - pie.outerLabelGroupData[i].y) / midPoint;
							x3 = pie.outerLabelGroupData[i].x + pie.outerLabelGroupData[i].w + labelXMargin;
							y3 = pie.outerLabelGroupData[i].y - heightOffset;
							break;
					}

					/*
					 * x1 / y1: the x/y coords of the start of the line, at the mid point of the segments arc on the pie circumference
					 * x2 / y2: if "curved" line style is being used, this is the midpoint of the line. Other
					 * x3 / y3: the end of the line; closest point to the label
					 */
					if (pie.options.labels.lines.style === "straight") {
						pie.lineCoordGroups[i] = [
							{ x: originCoords.x, y: originCoords.y },
							{ x: x3, y: y3 }
						];
					} else {
						pie.lineCoordGroups[i] = [
							{ x: originCoords.x, y: originCoords.y },
							{ x: x2, y: y2 },
							{ x: x3, y: y3 }
						];
					}
				},

				addLabelLines: function(pie) {
					var lineGroups = pie.svg.insert("g", "." + pie.cssPrefix + "pieChart") // meaning, BEFORE .pieChart
						.attr("class", pie.cssPrefix + "lineGroups")
						.style("opacity", 0);

					var lineGroup = lineGroups.selectAll("." + pie.cssPrefix + "lineGroup")
						.data(pie.lineCoordGroups)
						.enter()
						.append("g")
						.attr("class", pie.cssPrefix + "lineGroup");

					var lineFunction = d3.svg.line()
						.interpolate("basis")
						.x(function(d) { return d.x; })
						.y(function(d) { return d.y; });

					lineGroup.append("path")
						.attr("d", lineFunction)
						.attr("stroke", function(d, i) {
							return (pie.options.labels.lines.color === "segment") ? pie.options.colors[i] : pie.options.labels.lines.color;
						})
						.attr("stroke-width", 1)
						.attr("fill", "none")
						.style("opacity", function(d, i) {
							var percentage = pie.options.labels.outer.hideWhenLessThanPercentage;
							var segmentPercentage = segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces);
							var isHidden = (percentage !== null && segmentPercentage < percentage) || pie.options.data.content[i].label === "";
							return isHidden ? 0 : 1;
						});
				},

				positionLabelGroups: function(pie, section) {
			    if (pie.options.labels[section].format === "none") {
			      return;
			    }

					d3.selectAll("." + pie.cssPrefix + "labelGroup-" + section)
						.style("opacity", 0)
						.attr("transform", function(d, i) {
							var x, y;
							if (section === "outer") {
								x = pie.outerLabelGroupData[i].x;
								y = pie.outerLabelGroupData[i].y;
							} else {
								var pieCenterCopy = extend(true, {}, pie.pieCenter);

								// now recompute the "center" based on the current _innerRadius
								if (pie.innerRadius > 0) {
									var angle = segments.getSegmentAngle(i, pie.options.data.content, pie.totalSize, { midpoint: true });
									var newCoords = math.translate(pie.pieCenter.x, pie.pieCenter.y, pie.innerRadius, angle);
									pieCenterCopy.x = newCoords.x;
									pieCenterCopy.y = newCoords.y;
								}

								var dims = helpers.getDimensions(pie.cssPrefix + "labelGroup" + i + "-inner");
								var xOffset = dims.w / 2;
								var yOffset = dims.h / 4; // confusing! Why 4? should be 2, but it doesn't look right

								x = pieCenterCopy.x + (pie.lineCoordGroups[i][0].x - pieCenterCopy.x) / 1.8;
								y = pieCenterCopy.y + (pie.lineCoordGroups[i][0].y - pieCenterCopy.y) / 1.8;

								x = x - xOffset;
								y = y + yOffset;
							}

							return "translate(" + x + "," + y + ")";
						});
				},


				fadeInLabelsAndLines: function(pie) {

					// fade in the labels when the load effect is complete - or immediately if there's no load effect
					var loadSpeed = (pie.options.effects.load.effect === "default") ? pie.options.effects.load.speed : 1;
					setTimeout(function() {
						var labelFadeInTime = (pie.options.effects.load.effect === "default") ? 400 : 1; // 400 is hardcoded for the present

						d3.selectAll("." + pie.cssPrefix + "labelGroup-outer")
							.transition()
							.duration(function(){if(flag==1)return labelFadeInTime;else return 0;})
							.style("opacity", function(d, i) {
								var percentage = pie.options.labels.outer.hideWhenLessThanPercentage;
								var segmentPercentage = segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces);
								return (percentage !== null && segmentPercentage < percentage) ? 0 : 1;
							});

						d3.selectAll("." + pie.cssPrefix + "labelGroup-inner")
							.transition()
							.duration(function(){if(flag==1)return labelFadeInTime;else return 0;})
							.style("opacity", function(d, i) {
								var percentage = pie.options.labels.inner.hideWhenLessThanPercentage;
								var segmentPercentage = segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces);
								return (percentage !== null && segmentPercentage < percentage) ? 0 : 1;
							});

						d3.selectAll("g." + pie.cssPrefix + "lineGroups")
							.transition()
							.duration(function(){if(flag==1)return labelFadeInTime;else return 0;})
							.style("opacity", 1);

						// once everything's done loading, trigger the onload callback if defined
						if (helpers.isFunction(pie.options.callbacks.onload)) {
							setTimeout(function() {
								try {
									pie.options.callbacks.onload();
								} catch (e) { }
							}, function(){if(flag==1)return labelFadeInTime;else return 0;});
						}
					}, function(){if(flag==1)return loadSpeed;else return 0;});
				},

				getIncludes: function(val) {
					var addMainLabel  = false;
					var addValue      = false;
					var addPercentage = false;

					switch (val) {
						case "label":
							addMainLabel = true;
							break;
						case "value":
							addValue = true;
							break;
						case "percentage":
							addPercentage = true;
							break;
						case "label-value1":
						case "label-value2":
							addMainLabel = true;
							addValue = true;
							break;
						case "label-percentage1":
						case "label-percentage2":
							addMainLabel = true;
							addPercentage = true;
							break;
					}
					return {
						mainLabel: addMainLabel,
						value: addValue,
						percentage: addPercentage
					};
				},


				/**
				 * This does the heavy-lifting to compute the actual coordinates for the outer label groups. It does two things:
				 * 1. Make a first pass and position them in the ideal positions, based on the pie sizes
				 * 2. Do some basic collision avoidance.
				 */
				computeOuterLabelCoords: function(pie) {

					// 1. figure out the ideal positions for the outer labels
					pie.svg.selectAll("." + pie.cssPrefix + "labelGroup-outer")
						.each(function(d, i) {
							return labels.getIdealOuterLabelPositions(pie, i);
						});

					// 2. now adjust those positions to try to accommodate conflicts
					labels.resolveOuterLabelCollisions(pie);
				},

				/**
				 * This attempts to resolve label positioning collisions.
				 */
				resolveOuterLabelCollisions: function(pie) {
			    if (pie.options.labels.outer.format === "none") {
			      return;
			    }

					var size = pie.options.data.content.length;
					labels.checkConflict(pie, 0, "clockwise", size);
					labels.checkConflict(pie, size-1, "anticlockwise", size);
				},

				checkConflict: function(pie, currIndex, direction, size) {
			    var i, curr;

					if (size <= 1) {
						return;
					}

					var currIndexHemisphere = pie.outerLabelGroupData[currIndex].hs;
					if (direction === "clockwise" && currIndexHemisphere !== "right") {
						return;
					}
					if (direction === "anticlockwise" && currIndexHemisphere !== "left") {
						return;
					}
					var nextIndex = (direction === "clockwise") ? currIndex+1 : currIndex-1;

					// this is the current label group being looked at. We KNOW it's positioned properly (the first item
					// is always correct)
					var currLabelGroup = pie.outerLabelGroupData[currIndex];

					// this one we don't know about. That's the one we're going to look at and move if necessary
					var examinedLabelGroup = pie.outerLabelGroupData[nextIndex];

					var info = {
						labelHeights: pie.outerLabelGroupData[0].h,
						center: pie.pieCenter,
						lineLength: (pie.outerRadius + pie.options.labels.outer.pieDistance),
						heightChange: pie.outerLabelGroupData[0].h + 1 // 1 = padding
					};

					// loop through *ALL* label groups examined so far to check for conflicts. This is because when they're
					// very tightly fitted, a later label group may still appear high up on the page
					if (direction === "clockwise") {
			      i = 0;
						for (; i<=currIndex; i++) {
							curr = pie.outerLabelGroupData[i];

							// if there's a conflict with this label group, shift the label to be AFTER the last known
							// one that's been properly placed
							if (helpers.rectIntersect(curr, examinedLabelGroup)) {
								labels.adjustLabelPos(pie, nextIndex, currLabelGroup, info);
								break;
							}
						}
					} else {
			      i = size - 1;
						for (; i >= currIndex; i--) {
							curr = pie.outerLabelGroupData[i];

							// if there's a conflict with this label group, shift the label to be AFTER the last known
							// one that's been properly placed
							if (helpers.rectIntersect(curr, examinedLabelGroup)) {
								labels.adjustLabelPos(pie, nextIndex, currLabelGroup, info);
								break;
							}
						}
					}
					labels.checkConflict(pie, nextIndex, direction, size);
				},

				// does a little math to shift a label into a new position based on the last properly placed one
				adjustLabelPos: function(pie, nextIndex, lastCorrectlyPositionedLabel, info) {
					var xDiff, yDiff, newXPos, newYPos;
					newYPos = lastCorrectlyPositionedLabel.y + info.heightChange;
					yDiff = info.center.y - newYPos;

					if (Math.abs(info.lineLength) > Math.abs(yDiff)) {
						xDiff = Math.sqrt((info.lineLength * info.lineLength) - (yDiff * yDiff));
					} else {
						xDiff = Math.sqrt((yDiff * yDiff) - (info.lineLength * info.lineLength));
					}

					if (lastCorrectlyPositionedLabel.hs === "right") {
						newXPos = info.center.x + xDiff;
					} else {
						newXPos = info.center.x - xDiff - pie.outerLabelGroupData[nextIndex].w;
					}

					pie.outerLabelGroupData[nextIndex].x = newXPos;
					pie.outerLabelGroupData[nextIndex].y = newYPos;
				},

				/**
				 * @param i 0-N where N is the dataset size - 1.
				 */
				getIdealOuterLabelPositions: function(pie, i) {
			    var labelGroupNode = d3.select("#" + pie.cssPrefix + "labelGroup" + i + "-outer").node();
			    if (!labelGroupNode) {
			      return;
			    }
			    var labelGroupDims = labelGroupNode.getBBox();
					var angle = segments.getSegmentAngle(i, pie.options.data.content, pie.totalSize, { midpoint: true });

					var originalX = pie.pieCenter.x;
					var originalY = pie.pieCenter.y - (pie.outerRadius + pie.options.labels.outer.pieDistance);
					var newCoords = math.rotate(originalX, originalY, pie.pieCenter.x, pie.pieCenter.y, angle);

					// if the label is on the left half of the pie, adjust the values
					var hemisphere = "right"; // hemisphere
					if (angle > 180) {
						newCoords.x -= (labelGroupDims.width + 8);
						hemisphere = "left";
					} else {
						newCoords.x += 8;
					}

					pie.outerLabelGroupData[i] = {
						x: newCoords.x,
						y: newCoords.y,
						w: labelGroupDims.width,
						h: labelGroupDims.height,
						hs: hemisphere
					};
				}
			};

				//// --------- segments.js -----------
			var segments = {

				/**
				 * Creates the pie chart segments and displays them according to the desired load effect.
				 * @private
				 */
				create: function(pie) {
					var pieCenter = pie.pieCenter;
					var colors = pie.options.colors;
					var loadEffects = pie.options.effects.load;
					var segmentStroke = pie.options.misc.colors.segmentStroke;

					// we insert the pie chart BEFORE the title, to ensure the title overlaps the pie
					var pieChartElement = pie.svg.insert("g", "#" + pie.cssPrefix + "title")
						.attr("transform", function() { return math.getPieTranslateCenter(pieCenter); })
						.attr("class", pie.cssPrefix + "pieChart");

					var arc = d3.svg.arc()
						.innerRadius(pie.innerRadius)
						.outerRadius(pie.outerRadius)
						.startAngle(0)
						.endAngle(function(d) {
							return (d.value / pie.totalSize) * 2 * Math.PI;
						});

					var g = pieChartElement.selectAll("." + pie.cssPrefix + "arc")
						.data(pie.options.data.content)
						.enter()
						.append("g")
						.attr("class", pie.cssPrefix + "arc");

					// if we're not fading in the pie, just set the load speed to 0
					var loadSpeed = loadEffects.speed;
					if (loadEffects.effect === "none") {
						loadSpeed = 0;
					}

					g.append("path")
						.attr("id", function(d, i) { return pie.cssPrefix + "segment" + i; })
						.attr("fill", function(d, i) {
							var color = colors[i];
							if (pie.options.misc.gradient.enabled) {
								color = "url(#" + pie.cssPrefix + "grad" + i + ")";
							}
							return color;
						})
						.style("stroke", segmentStroke)
						.style("stroke-width", 1)
						.transition()
						.ease("cubic-in-out")
						.duration(function(){if(flag==1)return loadSpeed;else return 0;})
						.attr("data-index", function(d, i) { return i; })
						.attrTween("d", function(b) {
							var i = d3.interpolate({ value: 0 }, b);
							return function(t) {
								return pie.arc(i(t));
							};
						});

					pie.svg.selectAll("g." + pie.cssPrefix + "arc")
						.attr("transform",
						function(d, i) {
							var angle = 0;
							if (i > 0) {
								angle = segments.getSegmentAngle(i-1, pie.options.data.content, pie.totalSize);
							}
							return "rotate(" + angle + ")";
						}
					);
					pie.arc = arc;
				},

				addGradients: function(pie) {
					var grads = pie.svg.append("defs")
						.selectAll("radialGradient")
						.data(pie.options.data.content)
						.enter().append("radialGradient")
						.attr("gradientUnits", "userSpaceOnUse")
						.attr("cx", 0)
						.attr("cy", 0)
						.attr("r", "120%")
						.attr("id", function(d, i) { return pie.cssPrefix + "grad" + i; });

					grads.append("stop").attr("offset", "0%").style("stop-color", function(d, i) { return pie.options.colors[i]; });
					grads.append("stop").attr("offset", pie.options.misc.gradient.percentage + "%").style("stop-color", pie.options.misc.gradient.color);
				},

				addSegmentEventHandlers: function(pie) {
					var arc = d3.selectAll("." + pie.cssPrefix + "arc,." + pie.cssPrefix + "labelGroup-inner,." + pie.cssPrefix + "labelGroup-outer");

					arc.on("click", function() {
						var currentEl = d3.select(this);
						var segment;

						// mouseover works on both the segments AND the segment labels, hence the following
						if (currentEl.attr("class") === pie.cssPrefix + "arc") {
							segment = currentEl.select("path");
						} else {
							var index = currentEl.attr("data-index");
							segment = d3.select("#" + pie.cssPrefix + "segment" + index);
						}
						var isExpanded = segment.attr("class") === pie.cssPrefix + "expanded";
						segments.onSegmentEvent(pie, pie.options.callbacks.onClickSegment, segment, isExpanded);
						if (pie.options.effects.pullOutSegmentOnClick.effect !== "none") {
							if (isExpanded) {
								segments.closeSegment(pie, segment.node());
							} else {
								segments.openSegment(pie, segment.node());
							}
						}
					});

					arc.on("mouseover", function() {{
						var currentEl = d3.select(this);
						var segment;

						// mouseover works on both the segments AND the segment labels, hence the following
						if (currentEl.attr("class") === pie.cssPrefix + "arc") {
							segment = currentEl.select("path");
						} else {
							var index = currentEl.attr("data-index");
							segment = d3.select("#" + pie.cssPrefix + "segment" + index);
						}
						var isExpanded = segment.attr("class") === pie.cssPrefix + "expanded";
						segments.onSegmentEvent(pie, pie.options.callbacks.onClickSegment, segment, isExpanded);
						if (pie.options.effects.pullOutSegmentOnClick.effect !== "none") {
							if (isExpanded) {
								segments.closeSegment(pie, segment.node());
							} else {
								segments.openSegment(pie, segment.node());
							}
						}
					}{
						var currentEl = d3.select(this);
						var segment, index;

						if (currentEl.attr("class") === pie.cssPrefix + "arc") {
							segment = currentEl.select("path");
						} else {
							index = currentEl.attr("data-index");
							segment = d3.select("#" + pie.cssPrefix + "segment" + index);
						}

						if (pie.options.effects.highlightSegmentOnMouseover) {
							index = segment.attr("data-index");
							var segColor = pie.options.colors[index];
							segment.style("fill", helpers.getColorShade(segColor, pie.options.effects.highlightLuminosity));
						}

			      if (pie.options.tooltips.enabled) {
			        index = segment.attr("data-index");
			        tt.showTooltip(pie, index);
			      }

						var isExpanded = segment.attr("class") === pie.cssPrefix + "expanded";
						segments.onSegmentEvent(pie, pie.options.callbacks.onMouseoverSegment, segment, isExpanded);
					
					}
					});

				// 	arc.on("mouseover", function() {
				// 		var currentEl = d3.select(this);
				// 		var segment, index;

				// 		if (currentEl.attr("class") === pie.cssPrefix + "arc") {
				// 			segment = currentEl.select("path");
				// 		} else {
				// 			index = currentEl.attr("data-index");
				// 			segment = d3.select("#" + pie.cssPrefix + "segment" + index);
				// 		}

				// 		if (pie.options.effects.highlightSegmentOnMouseover) {
				// 			index = segment.attr("data-index");
				// 			var segColor = pie.options.colors[index];
				// 			segment.style("fill", helpers.getColorShade(segColor, pie.options.effects.highlightLuminosity));
				// 		}

			    //   if (pie.options.tooltips.enabled) {
			    //     index = segment.attr("data-index");
			    //     tt.showTooltip(pie, index);
			    //   }

				// 		var isExpanded = segment.attr("class") === pie.cssPrefix + "expanded";
				// 		segments.onSegmentEvent(pie, pie.options.callbacks.onMouseoverSegment, segment, isExpanded);
				// 	});

			    arc.on("mousemove", function() {
			      tt.moveTooltip(pie);
			    });

					arc.on("mouseout", function() {
						var currentEl = d3.select(this);
						var segment, index;

						if (currentEl.attr("class") === pie.cssPrefix + "arc") {
							segment = currentEl.select("path");
						} else {
							index = currentEl.attr("data-index");
							segment = d3.select("#" + pie.cssPrefix + "segment" + index);
						}

						if (pie.options.effects.highlightSegmentOnMouseover) {
							index = segment.attr("data-index");
							var color = pie.options.colors[index];
							if (pie.options.misc.gradient.enabled) {
								color = "url(#" + pie.cssPrefix + "grad" + index + ")";
							}
							segment.style("fill", color);
						}

			      if (pie.options.tooltips.enabled) {
			        index = segment.attr("data-index");
			        tt.hideTooltip(pie, index);
			      }

						var isExpanded = segment.attr("class") === pie.cssPrefix + "expanded";
						segments.onSegmentEvent(pie, pie.options.callbacks.onMouseoutSegment, segment, isExpanded);
					});
				},

				// helper function used to call the click, mouseover, mouseout segment callback functions
				onSegmentEvent: function(pie, func, segment, isExpanded) {
					if (!helpers.isFunction(func)) {
						return;
					}
					var index = parseInt(segment.attr("data-index"), 10);
					func({
						segment: segment.node(),
						index: index,
						expanded: isExpanded,
						data: pie.options.data.content[index]
					});
				},

				openSegment: function(pie, segment) {
					if (pie.isOpeningSegment) {
						return;
					}
					pie.isOpeningSegment = true;

					// close any open segments
					if (d3.selectAll("." + pie.cssPrefix + "expanded").length > 0) {
						segments.closeSegment(pie, d3.select("." + pie.cssPrefix + "expanded").node());
					}

					d3.select(segment).transition()
						.ease(pie.options.effects.pullOutSegmentOnClick.effect)
						.duration(pie.options.effects.pullOutSegmentOnClick.speed)
						.attr("transform", function(d, i) {
							var c = pie.arc.centroid(d),
								x = c[0],
								y = c[1],
								h = Math.sqrt(x*x + y*y),
								pullOutSize = parseInt(pie.options.effects.pullOutSegmentOnClick.size, 10);

							return "translate(" + ((x/h) * pullOutSize) + ',' + ((y/h) * pullOutSize) + ")";
						})
						.each("end", function(d, i) {
							pie.currentlyOpenSegment = segment;
							pie.isOpeningSegment = false;
							d3.select(this).attr("class", pie.cssPrefix + "expanded");
						});
				},

				closeSegment: function(pie, segment) {
					d3.select(segment).transition()
						.duration(400)
						.attr("transform", "translate(0,0)")
						.each("end", function(d, i) {
							d3.select(this).attr("class", "");
							pie.currentlyOpenSegment = null;
						});
				},

				getCentroid: function(el) {
					var bbox = el.getBBox();
					return {
						x: bbox.x + bbox.width / 2,
						y: bbox.y + bbox.height / 2
					};
				},

				/**
				 * General helper function to return a segment's angle, in various different ways.
				 * @param index
				 * @param opts optional object for fine-tuning exactly what you want.
				 */
				getSegmentAngle: function(index, data, totalSize, opts) {
					var options = extend({
						// if true, this returns the full angle from the origin. Otherwise it returns the single segment angle
						compounded: true,

						// optionally returns the midpoint of the angle instead of the full angle
						midpoint: false
					}, opts);

					var currValue = data[index].value;
					var fullValue;
					if (options.compounded) {
						fullValue = 0;

						// get all values up to and including the specified index
						for (var i=0; i<=index; i++) {
							fullValue += data[i].value;
						}
					}

					if (typeof fullValue === 'undefined') {
						fullValue = currValue;
					}

					// now convert the full value to an angle
					var angle = (fullValue / totalSize) * 360;

					// lastly, if we want the midpoint, factor that sucker in
					if (options.midpoint) {
						var currAngle = (currValue / totalSize) * 360;
						angle -= (currAngle / 2);
					}

					return angle;
				},

				getPercentage: function(pie, index, decimalPlaces) {
					var relativeAmount = pie.options.data.content[index].value / pie.totalSize;
					if (decimalPlaces <= 0) {
						return Math.round(relativeAmount * 100);
					} else {
						return (relativeAmount * 100).toFixed(decimalPlaces);
					}
				}

			};

				//// --------- text.js -----------
			var text = {
				offscreenCoord: -10000,

				addTitle: function(pie) {
					var title = pie.svg.selectAll("." + pie.cssPrefix + "title")
						.data([pie.options.header.title])
						.enter()
						.append("text")
						.text(function(d) { return d.text; })
						.attr({
			        id: pie.cssPrefix + "title",
			        class: pie.cssPrefix + "title",
			        x: text.offscreenCoord,
			        y: text.offscreenCoord
			      })
						.attr("text-anchor", function() {
							var location;
							if (pie.options.header.location === "top-center" || pie.options.header.location === "pie-center") {
								location = "middle";
							} else {
								location = "left";
							}
							return location;
						})
						.attr("fill", function(d) { return d.color; })
						.style("font-size", function(d) { return d.fontSize + "px"; })
						.style("font-family", function(d) { return d.font; });
				},

				positionTitle: function(pie) {
					var textComponents = pie.textComponents;
					var headerLocation = pie.options.header.location;
					var canvasPadding = pie.options.misc.canvasPadding;
					var canvasWidth = pie.options.size.canvasWidth;
					var titleSubtitlePadding = pie.options.header.titleSubtitlePadding;

					var x;
					if (headerLocation === "top-left") {
						x = canvasPadding.left;
					} else {
						x = ((canvasWidth - canvasPadding.right) / 2) + canvasPadding.left;
					}

			    // add whatever offset has been added by user
			    x += pie.options.misc.pieCenterOffset.x;

					var y = canvasPadding.top + textComponents.title.h;

					if (headerLocation === "pie-center") {
						y = pie.pieCenter.y;

						// still not fully correct
						if (textComponents.subtitle.exists) {
							var totalTitleHeight = textComponents.title.h + titleSubtitlePadding + textComponents.subtitle.h;
							y = y - (totalTitleHeight / 2) + textComponents.title.h;
						} else {
							y += (textComponents.title.h / 4);
						}
					}

					pie.svg.select("#" + pie.cssPrefix + "title")
						.attr("x", x)
						.attr("y", y);
				},

				addSubtitle: function(pie) {
					var headerLocation = pie.options.header.location;

					pie.svg.selectAll("." + pie.cssPrefix + "subtitle")
						.data([pie.options.header.subtitle])
						.enter()
						.append("text")
						.text(function(d) { return d.text; })
						.attr("x", text.offscreenCoord)
						.attr("y", text.offscreenCoord)
						.attr("id", pie.cssPrefix + "subtitle")
						.attr("class", pie.cssPrefix + "subtitle")
						.attr("text-anchor", function() {
							var location;
							if (headerLocation === "top-center" || headerLocation === "pie-center") {
								location = "middle";
							} else {
								location = "left";
							}
							return location;
						})
						.attr("fill", function(d) { return d.color; })
						.style("font-size", function(d) { return d.fontSize + "px"; })
						.style("font-family", function(d) { return d.font; });
				},

				positionSubtitle: function(pie) {
					var canvasPadding = pie.options.misc.canvasPadding;
					var canvasWidth = pie.options.size.canvasWidth;

					var x;
					if (pie.options.header.location === "top-left") {
						x = canvasPadding.left;
					} else {
						x = ((canvasWidth - canvasPadding.right) / 2) + canvasPadding.left;
					}

			    // add whatever offset has been added by user
			    x += pie.options.misc.pieCenterOffset.x;

					var y = text.getHeaderHeight(pie);
					pie.svg.select("#" + pie.cssPrefix + "subtitle")
						.attr("x", x)
						.attr("y", y);
				},

				addFooter: function(pie) {
					pie.svg.selectAll("." + pie.cssPrefix + "footer")
						.data([pie.options.footer])
						.enter()
						.append("text")
						.text(function(d) { return d.text; })
						.attr("x", text.offscreenCoord)
						.attr("y", text.offscreenCoord)
						.attr("id", pie.cssPrefix + "footer")
						.attr("class", pie.cssPrefix + "footer")
						.attr("text-anchor", function() {
							var location = "left";
							if (pie.options.footer.location === "bottom-center") {
								location = "middle";
							} else if (pie.options.footer.location === "bottom-right") {
								location = "left"; // on purpose. We have to change the x-coord to make it properly right-aligned
							}
							return location;
						})
						.attr("fill", function(d) { return d.color; })
						.style("font-size", function(d) { return d.fontSize + "px"; })
						.style("font-family", function(d) { return d.font; });
				},

				positionFooter: function(pie) {
					var footerLocation = pie.options.footer.location;
					var footerWidth = pie.textComponents.footer.w;
					var canvasWidth = pie.options.size.canvasWidth;
					var canvasHeight = pie.options.size.canvasHeight;
					var canvasPadding = pie.options.misc.canvasPadding;

					var x;
					if (footerLocation === "bottom-left") {
						x = canvasPadding.left;
					} else if (footerLocation === "bottom-right") {
						x = canvasWidth - footerWidth - canvasPadding.right;
					} else {
						x = canvasWidth / 2; // TODO - shouldn't this also take into account padding?
					}

					pie.svg.select("#" + pie.cssPrefix + "footer")
						.attr("x", x)
						.attr("y", canvasHeight - canvasPadding.bottom);
				},

				getHeaderHeight: function(pie) {
					var h;
					if (pie.textComponents.title.exists) {

						// if the subtitle isn't defined, it'll be set to 0
						var totalTitleHeight = pie.textComponents.title.h + pie.options.header.titleSubtitlePadding + pie.textComponents.subtitle.h;
						if (pie.options.header.location === "pie-center") {
							h = pie.pieCenter.y - (totalTitleHeight / 2) + totalTitleHeight;
						} else {
							h = totalTitleHeight + pie.options.misc.canvasPadding.top;
						}
					} else {
						if (pie.options.header.location === "pie-center") {
							var footerPlusPadding = pie.options.misc.canvasPadding.bottom + pie.textComponents.footer.h;
							h = ((pie.options.size.canvasHeight - footerPlusPadding) / 2) + pie.options.misc.canvasPadding.top + (pie.textComponents.subtitle.h / 2);
						} else {
							h = pie.options.misc.canvasPadding.top + pie.textComponents.subtitle.h;
						}
					}
					return h;
				}
			};

			  //// --------- validate.js -----------
			var tt = {
				addTooltips: function(pie) {

					// group the label groups (label, percentage, value) into a single element for simpler positioning
					var tooltips = pie.svg.insert("g")
						.attr("class", pie.cssPrefix + "tooltips");

			    tooltips.selectAll("." + pie.cssPrefix + "tooltip")
			      .data(pie.options.data.content)
			      .enter()
			      .append("g")
			        .attr("class", pie.cssPrefix + "tooltip")
			        .attr("id", function(d, i) { return pie.cssPrefix + "tooltip" + i; })
			        .style("opacity", 0)
			      .append("rect")
			        .attr({
						    rx: pie.options.tooltips.styles.borderRadius,
						    ry: pie.options.tooltips.styles.borderRadius,
						    x: -pie.options.tooltips.styles.padding,
						    opacity: pie.options.tooltips.styles.backgroundOpacity
					    })
					    .style("fill", pie.options.tooltips.styles.backgroundColor);

			    tooltips.selectAll("." + pie.cssPrefix + "tooltip")
			      .data(pie.options.data.content)
			      .append("text")
			        .attr("fill", function(d) { return pie.options.tooltips.styles.color; })
			        .style("font-size", function(d) { return pie.options.tooltips.styles.fontSize; })
			        .style("font-family", function(d) { return pie.options.tooltips.styles.font; })
			        .text(function(d, i) {
			          var caption = pie.options.tooltips.string;
			          if (pie.options.tooltips.type === "caption") {
			            caption = d.caption;
			          }
			          return tt.replacePlaceholders(pie, caption, i, {
			            label: d.label,
			            value: d.value,
			            percentage: segments.getPercentage(pie, i, pie.options.labels.percentage.decimalPlaces)
			          });
			        });

					tooltips.selectAll("." + pie.cssPrefix + "tooltip rect")
						.attr({
							width: function (d, i) {
								var dims = helpers.getDimensions(pie.cssPrefix + "tooltip" + i);
								return dims.w + (2 * pie.options.tooltips.styles.padding);
							},
							height: function (d, i) {
								var dims = helpers.getDimensions(pie.cssPrefix + "tooltip" + i);
								return dims.h + (2 * pie.options.tooltips.styles.padding);
							},
							y: function (d, i) {
								var dims = helpers.getDimensions(pie.cssPrefix + "tooltip" + i);
								return -(dims.h / 2) + 1;
							}
						});
				},

			  showTooltip: function(pie, index) {

				  var fadeInSpeed = pie.options.tooltips.styles.fadeInSpeed;
				  if (tt.currentTooltip === index) {
					  fadeInSpeed = 1;
				  }

			    tt.currentTooltip = index;
			    d3.select("#" + pie.cssPrefix + "tooltip" + index)
			      .transition()
			      .duration(fadeInSpeed)
			      .style("opacity", function() { return 1; });

			    tt.moveTooltip(pie);
			  },

			  moveTooltip: function(pie) {
			    d3.selectAll("#" + pie.cssPrefix + "tooltip" + tt.currentTooltip)
			      .attr("transform", function(d) {
			        var mouseCoords = d3.mouse(this.parentNode);
			        var x = mouseCoords[0] + pie.options.tooltips.styles.padding + 2;
			        var y = mouseCoords[1] - (2 * pie.options.tooltips.styles.padding) - 2;
			        return "translate(" + x + "," + y + ")";
			      });
			  },

			  hideTooltip: function(pie, index) {
			    d3.select("#" + pie.cssPrefix + "tooltip" + index)
			      .style("opacity", function() { return 0; });

			    // move the tooltip offscreen. This ensures that when the user next mouseovers the segment the hidden
			    // element won't interfere
			    d3.select("#" + pie.cssPrefix + "tooltip" + tt.currentTooltip)
			       .attr("transform", function(d, i) {

			         // klutzy, but it accounts for tooltip padding which could push it onscreen
			         var x = pie.options.size.canvasWidth + 1000;
			         var y = pie.options.size.canvasHeight + 1000;
			         return "translate(" + x + "," + y + ")";
			       });
			  },

			  replacePlaceholders: function(pie, str, index, replacements) {

			    // if the user has defined a placeholderParser function, call it before doing the replacements
			    if (helpers.isFunction(pie.options.tooltips.placeholderParser)) {
			      pie.options.tooltips.placeholderParser(index, replacements);
			    }

			    var replacer = function()  {
			      return function(match) {
			        var placeholder = arguments[1];
			        if (replacements.hasOwnProperty(placeholder)) {
			          return replacements[arguments[1]];
			        } else {
			          return arguments[0];
			        }
			      };
			    };
			    return str.replace(/\{(\w+)\}/g, replacer(replacements));
			  }
			};


				// --------------------------------------------------------------------------------------------

				// our constructor
				var d3pie = function(element, options) {

					// element can be an ID or DOM element
					this.element = element;
					if (typeof element === "string") {
						var el = element.replace(/^#/, ""); // replace any jQuery-like ID hash char
						this.element = document.getElementById(el);
					}

					var opts = {};
					extend(true, opts, defaultSettings, options);
					this.options = opts;

					// if the user specified a custom CSS element prefix (ID, class), use it
					if (this.options.misc.cssPrefix !== null) {
						this.cssPrefix = this.options.misc.cssPrefix;
					} else {
						this.cssPrefix = "p" + _uniqueIDCounter + "_";
						_uniqueIDCounter++;
					}


					// now run some validation on the user-defined info
					if (!validate.initialCheck(this)) {
						return;
					}

					// add a data-role to the DOM node to let anyone know that it contains a d3pie instance, and the d3pie version
					d3.select(this.element).attr(_scriptName, _version);

					// things that are done once
					this.options.data.content = math.sortPieData(this);
					if (this.options.data.smallSegmentGrouping.enabled) {
						this.options.data.content = helpers.applySmallSegmentGrouping(this.options.data.content, this.options.data.smallSegmentGrouping);
					}
					this.options.colors = helpers.initSegmentColors(this);
					this.totalSize      = math.getTotalPieSize(this.options.data.content);

					_init.call(this);
				};

				d3pie.prototype.recreate = function() {
					// now run some validation on the user-defined info
					if (!validate.initialCheck(this)) {
						return;
					}
					this.options.data.content = math.sortPieData(this);
					if (this.options.data.smallSegmentGrouping.enabled) {
						this.options.data.content = helpers.applySmallSegmentGrouping(this.options.data.content, this.options.data.smallSegmentGrouping);
					}
					this.options.colors = helpers.initSegmentColors(this);
					this.totalSize      = math.getTotalPieSize(this.options.data.content);

					_init.call(this);
				};

				d3pie.prototype.redraw = function() {
					this.element.innerHTML = "";
					_init.call(this);
				};

				d3pie.prototype.destroy = function() {
					this.element.innerHTML = ""; // clear out the SVG
					d3.select(this.element).attr(_scriptName, null); // remove the data attr
				};

				/**
				 * Returns all pertinent info about the current open info. Returns null if nothing's open, or if one is, an object of
				 * the following form:
				 * 	{
				 * 	  element: DOM NODE,
				 * 	  index: N,
				 * 	  data: {}
				 * 	}
				 */
				d3pie.prototype.getOpenSegment = function() {
					var segment = this.currentlyOpenSegment;
					if (segment !== null && typeof segment !== "undefined") {
						var index = parseInt(d3.select(segment).attr("data-index"), 10);
						return {
							element: segment,
							index: index,
							data: this.options.data.content[index]
						};
					} else {
						return null;
					}
				};

				d3pie.prototype.openSegment = function(index) {
					index = parseInt(index, 10);
					if (index < 0 || index > this.options.data.content.length-1) {
						return;
					}
					segments.openSegment(this, d3.select("#" + this.cssPrefix + "segment" + index).node());
				};

				d3pie.prototype.closeSegment = function() {
					var segment = this.currentlyOpenSegment;
					if (segment) {
						segments.closeSegment(this, segment);
					}
				};

				// this let's the user dynamically update aspects of the pie chart without causing a complete redraw. It
				// intelligently re-renders only the part of the pie that the user specifies. Some things cause a repaint, others
				// just redraw the single element
				d3pie.prototype.updateProp = function(propKey, value) {
					switch (propKey) {
						case "header.title.text":
							var oldVal = helpers.processObj(this.options, propKey);
							helpers.processObj(this.options, propKey, value);
							d3.select("#" + this.cssPrefix + "title").html(value);
							if ((oldVal === "" && value !== "") || (oldVal !== "" && value === "")) {
								this.redraw();
							}
							break;

						case "header.subtitle.text":
							var oldValue = helpers.processObj(this.options, propKey);
							helpers.processObj(this.options, propKey, value);
							d3.select("#" + this.cssPrefix + "subtitle").html(value);
							if ((oldValue === "" && value !== "") || (oldValue !== "" && value === "")) {
								this.redraw();
							}
							break;

						case "callbacks.onload":
						case "callbacks.onMouseoverSegment":
						case "callbacks.onMouseoutSegment":
						case "callbacks.onClickSegment":
						case "effects.pullOutSegmentOnClick.effect":
						case "effects.pullOutSegmentOnClick.speed":
						case "effects.pullOutSegmentOnClick.size":
						case "effects.highlightSegmentOnMouseover":
						case "effects.highlightLuminosity":
							helpers.processObj(this.options, propKey, value);
							break;

						// everything else, attempt to update it & do a repaint
						default:
							helpers.processObj(this.options, propKey, value);

							this.destroy();
							this.recreate();
							break;
					}
				};


				// ------------------------------------------------------------------------------------------------


				var _init = function() {

					// prep-work
					this.svg = helpers.addSVGSpace(this);

					// store info about the main text components as part of the d3pie object instance
					this.textComponents = {
						headerHeight: 0,
						title: {
							exists: this.options.header.title.text !== "",
							h: 0,
							w: 0
						},
						subtitle: {
							exists: this.options.header.subtitle.text !== "",
							h: 0,
							w: 0
						},
						footer: {
							exists: this.options.footer.text !== "",
							h: 0,
							w: 0
						}
					};

					this.outerLabelGroupData = [];

					// add the key text components offscreen (title, subtitle, footer). We need to know their widths/heights for later computation
					if (this.textComponents.title.exists) {
						text.addTitle(this);
					}
					if (this.textComponents.subtitle.exists) {
						text.addSubtitle(this);
					}
					text.addFooter(this);

					// the footer never moves. Put it in place now
					var self = this;
					helpers.whenIdExists(this.cssPrefix + "footer", function() {
						text.positionFooter(self);
						var d3 = helpers.getDimensions(self.cssPrefix + "footer");
						self.textComponents.footer.h = d3.h;
						self.textComponents.footer.w = d3.w;
					});

					// now create the pie chart and position everything accordingly
					var reqEls = [];
					if (this.textComponents.title.exists)    { reqEls.push(this.cssPrefix + "title"); }
					if (this.textComponents.subtitle.exists) { reqEls.push(this.cssPrefix + "subtitle"); }
					if (this.textComponents.footer.exists)   { reqEls.push(this.cssPrefix + "footer"); }

					helpers.whenElementsExist(reqEls, function() {
						if (self.textComponents.title.exists) {
							var d1 = helpers.getDimensions(self.cssPrefix + "title");
							self.textComponents.title.h = d1.h;
							self.textComponents.title.w = d1.w;
						}
						if (self.textComponents.subtitle.exists) {
							var d2 = helpers.getDimensions(self.cssPrefix + "subtitle");
							self.textComponents.subtitle.h = d2.h;
							self.textComponents.subtitle.w = d2.w;
						}
						// now compute the full header height
						if (self.textComponents.title.exists || self.textComponents.subtitle.exists) {
							var headerHeight = 0;
							if (self.textComponents.title.exists) {
								headerHeight += self.textComponents.title.h;
								if (self.textComponents.subtitle.exists) {
									headerHeight += self.options.header.titleSubtitlePadding;
								}
							}
							if (self.textComponents.subtitle.exists) {
								headerHeight += self.textComponents.subtitle.h;
							}
							self.textComponents.headerHeight = headerHeight;
						}

						// at this point, all main text component dimensions have been calculated
						math.computePieRadius(self);

						// this value is used all over the place for placing things and calculating locations. We figure it out ONCE
						// and store it as part of the object
						math.calculatePieCenter(self);

						// position the title and subtitle
						text.positionTitle(self);
						text.positionSubtitle(self);

						// now create the pie chart segments, and gradients if the user desired
						if (self.options.misc.gradient.enabled) {
							segments.addGradients(self);
						}
						segments.create(self); // also creates this.arc
						labels.add(self, "inner", self.options.labels.inner.format);
						labels.add(self, "outer", self.options.labels.outer.format);

						// position the label elements relatively within their individual group (label, percentage, value)
						labels.positionLabelElements(self, "inner", self.options.labels.inner.format);
						labels.positionLabelElements(self, "outer", self.options.labels.outer.format);
						labels.computeOuterLabelCoords(self);

						// this is (and should be) dumb. It just places the outer groups at their calculated, collision-free positions
						labels.positionLabelGroups(self, "outer");

						// we use the label line positions for many other calculations, so ALWAYS compute them
						labels.computeLabelLinePositions(self);

						// only add them if they're actually enabled
						if (self.options.labels.lines.enabled && self.options.labels.outer.format !== "none") {
							labels.addLabelLines(self);
						}

						labels.positionLabelGroups(self, "inner");
						labels.fadeInLabelsAndLines(self);

			      // add and position the tooltips
			      if (self.options.tooltips.enabled) {
			        tt.addTooltips(self);
			      }

			      segments.addSegmentEventHandlers(self);
					});
				};

			  return d3pie;
			}));
		
		/*	Script End	*/ 
		// Note: Now you can start reading again
		/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

		var d = Object.values(values[0]).slice(8,15);
		var data = [];
		
		
		for(var i=0;i<d.length;i++){
			if(i==0)data.push({"label":"Lead Bucket","value":d[i]});
			if(i==1)data.push({"label":"Call/Negotiation","value":d[i]});
			if(i==2)data.push({"label":"Lead Qualified","value":d[i]});
			if(i==3)data.push({"label":"Sale Won","value":d[i]});
			if(i==4)data.push({"label":"Site Visit","value":d[i]});
			if(i==5)data.push({"label":"Follow Up","value":d[i]});
			if(i==6)data.push({"label":"Sale Lost","value":d[i]});
		}
		
		console.log("This is the Data " +data);
		
		
			
			var pie3 = new d3pie("pie", {
				data: {
					content: data
				},
			    tooltips: {
			        enabled: true,
			        type: "placeholder",
			        string: "{label}: {percentage}%",
			        styles: {
			          fadeInSpeed: 100,
			          backgroundColor: "#00cc99",
			          backgroundOpacity: 0.8,
			          color: "#ffffcc",
			          borderRadius: 4,
			          font: "verdana",
			          fontSize: 15,
			          padding: 5
			        }
			      }
			});
			
		
//prevValue = values;
	}
	}	
	prevValue = values;
}

buildPieChart(pieData,1);
</script>

<script>
var opt;
var refFlagUser = 0;
var refFlagProject = 0;
$("#userId").on('change',function(){ 
	console.log("change");
  var user_id = $(this).val();
  console.log("user_id " + user_id);
  var dataString={'user_id':user_id}; 
  var filter_id = $('#projectId').find(":selected").val();
  console.log("filter_id " + filter_id);
  var filter_text = $('#projectId').find(":selected").text();
  console.log("filter_text " + filter_text);
  
 if(refFlagUser!=1){
	 $.ajax({
		    type: "GET",
		   
		    url: "${pageContext.request.contextPath}/userProjectDetails",
		    data : ({
				'user_id':user_id,
				'filter_id':filter_id
			}),
		  
		    success: function (projectList) {
			    	$('#projectId').empty();
		    		opt = '<option value="'+ filter_id +'" selected>'+ filter_text +'</option>';
		    		console.log(projectList.length + " projectList.length");
			    	   for (var i = 0; i <= projectList.length; i++) {
			    		  console.log("iiii project" + i);
			    		   $('#projectId').append(opt);
			    		   if(filter_id=='' && i==projectList.length)break;
			    		   opt = new Option(projectList[i].project_name+"- ("+projectList[i].project_id+")",projectList[i].project_id);
			    		  	
			            }
		    	
		    	
		    	}
		  }); 
	 
 }
 refFlagUser = 0;

});



$("#projectId").on('change',function(){ 
	console.log("change");
  var project_id = $(this).val();
  console.log("project_id " + project_id);
  var dataString={'project_id':project_id}; 
  var filter_id = $('#userId').find(":selected").val();
  console.log("filter_id " + filter_id);
  var filter_text = $('#userId').find(":selected").text();
  console.log("filter_text " + filter_text);
  
  if(refFlagProject != 1){
	  
	  $.ajax({
		    type: "GET",
		   
		    url: "${pageContext.request.contextPath}/projectUserDetails",
		    data : ({
				'project_id':project_id,
				'filter_id':filter_id
			}),
		  
		    success: function (userList) {
		    		$('#userId').empty();
		    		opt = '<option value="'+ filter_id +'" selected>'+ filter_text +'</option>';
		    		console.log(userList.length + " userList.length");   
		    		for (var i = 0; i <= userList.length; i++) {
			    		   console.log("iiii user" + i);
			    		   $('#userId').append(opt); 
			    		   if(i==userList.length)break;
			    		   opt = new Option(userList[i].user_name+"- ("+userList[i].user_id+")",userList[i].user_id);

			            }
		    	
			    		
		    	}
		  });
	  
  }
  refFlagProject = 0;

});



$(".selectOption").on('change',function(){
	var userId = $('#userId').val();
	console.log("userId " + userId);
	var projectId = $('#projectId').val();
	console.log("projectId " + projectId);
	var piedt = $.ajax({
	    type: "GET",
	    contentType: "application/json; charset=utf-8",
	    url: "${pageContext.request.contextPath}/getPieChart1Data",
	    dataType: 'json',
	    async:false,
	    data : ({
			'userId':userId,
			'projectId':projectId
		}),beforeSend:function(){
				$(function() {

	  				   var docHeight = $(document).height();

	  				   $("body").append("<div class='overlay'></div>");

	  				   $(".overlay")
	  				      .height(docHeight)
	  				      .css({
	  				         'opacity' : 0.7,
	  				         'position': 'fixed',
	  				         'top': 0,
	  				         'left': 0,
	  				         'right':0,
	  				         'background-color': 'black',
	  				         'width': '100%',
	  				         'z-index': 5000
	  				      });
	  			});	
 				$('#image').css('z-index','6000');
	  			}, 
	    success: function (data) {
	    	return data;
	    },
	    	complete:function(){
	    		$(function() {

	  				   var docHeight = $(document).height();

	  				   $("body").append("<div class='overlay'></div>");

	  				   $(".overlay")
	  				      .height(docHeight)
	  				      .css({
	  				         'opacity' : 0.7,
	  				         'position': 'fixed',
	  				         'top': 0,
	  				         'left': 0,
	  				         'right':0,
	  				         'background-color': '#fff',
	  				         'width': '100%',
	  				         'z-index': -1
	  				      });
	  			});
		    	$('#image').css('z-index','-1');
		    	}
	});

	console.log("piedt Response " + piedt.responseText);

	piedt = JSON.parse(piedt.responseText);
	buildBarForPie(piedt,0);
	buildPieChart(piedt,1);
});

$(".ref").click(function () {
	   var docHeight = $(document).height();

	   $("body").append("<div class='overlay'></div>");

	   $(".overlay")
	      .height(docHeight)
	      .css({
	         'opacity' : 0.7,
	         'position': 'fixed',
	  				         'top': 0,
	  				         'left': 0,
	  				         'right':0,
	         'background-color': 'black',
	         'width': '100%',
	         'z-index': 5000
	      });
	$('#image').css('z-index','6000');
refFlagUser = 1;
refFlagProject = 1;
$('.fa').toggleClass("back");
	interval();
	interval_2();
	interval_3();
	$(".select2").val('').trigger('change');
	$(".select21").val('').trigger('change');
	$.ajax({
	    type: "GET",
	   
	    url: "${pageContext.request.contextPath}/userList",
	    data : ({
			'1':1
		}),
		 
	    success: function (userList) {
		    		$('#userId').empty();
		    		opt = '<option value="" disabled selected>Select User</option>';
			    	   for (var i = 0; i <= userList.length; i++) {
			    		   
			    		   $('#userId').append(opt); 
			    		  if(i==userList.length)break;
			    		   opt = new Option(userList[i].user_name+"- ("+userList[i].user_id+")",userList[i].user_id);
				                       }
	    	}
	  });
	
	$.ajax({
	    type: "GET",
	   
	    url: "${pageContext.request.contextPath}/projectList",
	    data : ({
			'1':1
		}),
	  
	    success: function (projectList) {	
	    	$('#projectId').empty();
		    		opt = '<option value="" disabled selected>Select Project</option>';
			    	   for (var i = 0; i <= projectList.length; i++) {
			    		   $('#projectId').append(opt); 
			    		  if(i==projectList.length)break;
			    		   opt = new Option(projectList[i].project_name+"- ("+projectList[i].project_id+")",projectList[i].project_id);

				            	
			            }
	    	},
	    	complete:function(){
	    		$('.overlay').remove();	
	    		$('#image').css('z-index','-1');
	    	}
	  });
	
	
});
	
	
$(".ref1").click(function () {
	refFlagUser = 1;
	refFlagProject = 1;
	
	$('.fa').toggleClass("back");
		interval();
    	interval_2();
    	interval_3();
    	$(".select21").val('').trigger('change');

 		
 		$.ajax({
 		    type: "GET",
 		   
 		    url: "${pageContext.request.contextPath}/projectList",
 		    data : ({
 				'1':1
 			}),
 		  
 		    success: function (projectList) {
 		    	
 			    		$('#projectId').empty();
 			    		opt = '<option value="" disabled selected>Select Project</option>';
 				    	   for (var i = 0; i <= projectList.length; i++) {
 				    		   $('#projectId').append(opt); 
 				    		  if(i==projectList.length)break;
 				    		   opt = new Option(projectList[i].project_name+"- ("+projectList[i].project_id+")",projectList[i].project_id);

 					            	
 				            }
 		    	}
 		  });
 		
    	
	});
	
	
var refresh = function () {
	refFlagUser = 1;
	refFlagProject = 1;
	
	$('.fa').toggleClass("back");
		interval();
    	interval_2();
    	interval_3();
    	$(".select2").val('').trigger('change');
    	$(".select21").val('').trigger('change');
    	$.ajax({
 		    type: "GET",
 		   
 		    url: "${pageContext.request.contextPath}/userList",
 		    data : ({
 				'1':1
 			}),
 		  
 		    success: function (userList) {
 		    	
 			    		$('#userId').empty();
 			    		opt = '<option value="" disabled selected>Select User</option>';
 				    	   for (var i = 0; i <= userList.length; i++) {
 				    		   
 				    		   $('#userId').append(opt); 
 				    		  if(i==userList.length)break;
 				    		   opt = new Option(userList[i].user_name+"- ("+userList[i].user_id+")",userList[i].user_id);

 					            	
 				            }
 		    	}
 		  });
 		
 		$.ajax({
 		    type: "GET",
 		   
 		    url: "${pageContext.request.contextPath}/projectList",
 		    data : ({
 				'1':1
 			}),
 		  
 		    success: function (projectList) {
 		    	
 			    		$('#projectId').empty();
 			    		opt = '<option value="" disabled selected>Select Project</option>';
 				    	   for (var i = 0; i <= projectList.length; i++) {
 				    		   $('#projectId').append(opt); 
 				    		  if(i==projectList.length)break;
 				    		   opt = new Option(projectList[i].project_name+"- ("+projectList[i].project_id+")",projectList[i].project_id);

 					            	
 				            }
 		    	}
 		  });
 		
    	
	};
	

</script>


<style>
body{
	min-width:500px;
}
.rotate {
    -moz-transition: all .5s linear;
    -webkit-transition: all .5s linear;
    transition: all .5s linear;
}
.rotate.back {
    -moz-transform:rotate(360deg);
    -webkit-transform:rotate(360deg);
    transform:rotate(360deg);
}


.select2-container{
	width:314px !important;
}

#fullBarChart{
	background-color:#fff;
}

@media screen and (max-width: 1140px){
	.headingTextHide {
		display:none !important;
	}
}

@media screen and (min-width: 1140px){
	.smallDivs{
		display:none !important;
	}
}
</style>

<script>
var showGif = function(){
	var img = document.getElementById('image');
	img.src = '/PSG/resources/gif/loading1.gif';
	img.style.cssText="position: fixed; top: 50%; left: 50%; width: 80px; height: 80px; margin-top: -40px; /* Half the height */ margin-left: -40px;z-index:-1; /* Half the width */";
	
	}

$(window).on('load', function(){
	$('.overlay').remove();
	$('#image').css('z-index','-1');
	$('.divs').show();
});
</script>







<script>

$(document).ready(function(){ 
	var lead_count=document.getElementById("lead_count").value;
	var case_count=document.getElementById("case_count").value;
	//alert(lead_count);
//	alert(case_count);
	if(Number(lead_count)!=0 || Number(case_count)!=0)
		{
	$('#myModal').modal({show:true,backdrop: 'static',
        keyboard: false});
		}

	    }); 

</script>
</body>
</html>

